c     The KCA function calculates K corrections based on the templates
c     generated by Assef & Kochanek et al. 2006 (in preparation). 
c     The arguments are:
c
c
c     num     = number of bands on which the photometry is being
c               supplied (integer)
c     
c     mag     = vector of n components containing the observed 
c               magnitudes (real*8)
c     
c     emag    = vector of n components containing the errors in the 
c               magnitudes (real*8)
c     
c     maguse  = vector of n components containing which magnitudes will
c               be used to fit the galaxy to the templates. 1 means to
c               be used and 0 to not be used.  For bands not used in
c               the fit, a kcorrection will also be calculated as well
c               as a model flux. (integer)
c     
c     zobj    = redshift of the galaxy (real*8)
c
c     z0      = redshift to which you want to k correct (real*8)
c     
c     magmod  = vector of n components on which the modeled magnitudes
c               will be returned (real*8)
c     
c     magcorr = vector of n components on which the kcorrections in
c               magnitudes are returned (real*8)
c
c     comp    = vector with at least dimensions equal to the number
c               of templates used (real*8)
c     
c     op      = 1 if mag is in magnitudes and 0 if it is in flux. 
c     
c     
c     Note that the following functions do not necessarily follow the 80
c     character per line fortran 77 convention. Compilation with g77 has
c     to include the -ffixed-line-length-none flag. Compilation with
c     intel fortran compiler, ifort, has to include the -extend_source
c     flag. Also note that min.f should be compiled simultaneously.
c     
c     This function should only be called after calling setfilt and
c     settemp.



      subroutine kca(mag,emag,maguse,num,zobj,z0,magmod,magcorr,comp,op,xebv1,xebv2,xigm,chi2)
      implicit real*8(a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5,NTMAX=5)

      real*8 mag(*),emag(*),magmod(*),magcorr(*),comp(*)
      integer maguse(*),op

      real*8 z
      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan
      common /data1/z

      integer jyuse(NCMAX)
      common /data2/jyuse

      real*8 vec(NSMAX)
      real*8 jymod(NSMAX,NCMAX)
      real*8 jymodtot(NCMAX)
      common /models/jymod,jymodtot,vec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      integer ivaryobj(NSMAX)
      common /ivary/ivaryobj

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      real*8 tigm(NWMAX)

      real*8 wgt0(NCMAX,NWMAX)

      real*8 jymodz0(NSMAX,NCMAX),jymodz0tot(NCMAX),jycorr(NCMAX)

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec
      common /specnorm/bminnorm,bmaxnorm

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 zlim,zlim_old
      real*8 jymodlim(NSMAX,NCMAX),jymodlimtot(NCMAX)      
      real*8 magl,mlim

      real*8 chimin
      common /minchi/chimin

      real*8 err_comp(NSMAX)
      common /comperr/err_comp

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix


      nchan = num
      z = zobj

c     See which bands will be used for fitting.

      do j = 1,nchan
         if(maguse(j).ne.0.and.maguse(j).ne.1.and.maguse(j).ne.2) then
            print*,'maguse(',j,')=',maguse(j),' not equal to 1 or 0'
            print*,'Aborting program'
            stop
         else
            jyuse(j) = maguse(j)
         endif
      enddo


      if(op.eq.1) then

c     If op = 1, transform from magnitudes to fluxes. 

         do jchan = 1,nchan
            jy(jchan)  = jyzero(jchan)*10.0**(-0.4*mag(jchan))
            ejy(jchan) = 0.4*log(10.0)*emag(jchan)*jy(jchan)
            ejy(jchan) = ejy(jchan)**2
         enddo
         
      else if(op.eq.0) then

c     If op = 0, data is in flux.

         do jchan = 1,nchan
            jy(jchan)  = mag(jchan)
            ejy(jchan) = emag(jchan)
            ejy(jchan) = ejy(jchan)**2
         enddo
         
      else
         print*,'Not a valid value for op.'
         print*,'Input 0 if data is in Jy and 1 if data is in magnitudes'
c'
         stop
      endif



c     Build the weights
      
      do jchan=1,nchan
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z,jchan,kwave)
         enddo
         call getrange(jchan)         
      enddo


c     Now Fit the Model Fluxes to the spectra

      
      do l=1,nspec
         vec(l) = 0.0d0
      enddo
c      do l = 1,nspec
c         ivaryobj(l) = 1
c      enddo
c      ivaryobj(1) = 0


      call fitgal


c     Calculate the models at redshift z and redshift 0 
         
      do jchan=1,nchan
        
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z0,jchan,kwave)
         enddo
         call getrange(jchan)
         
      enddo


      do k = 1,nwave
         tigm(k) = transmit(bcen(k),z,igm)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymodz0(l,j) = 0.d0
            do k=jwmin(j),jwmax(j)
               if(l.eq.1) then
                  dust = 10.d0**(-0.4*tau(k)*ebv1)
               else if(l.eq.5) then
                  dust = 10.d0**(-0.4*tau(k)*ebv2)
               else
                  dust = 1.d0
               endif
               jymodz0(l,j) = jymodz0(l,j) + 
     *              c(j)*spec(l,k)*wgt(j,k)*dust*tigm(k)
            enddo
            if(jymodz0(l,j).eq.0.0) then 
               print*,j,l,jwmin(j),jwmax(j),bedge(jwmin(j)),bedge(jwmax(j))
               pause
            endif
         enddo
      enddo


      do j=1,nchan
         jymodtot(j)   = 0.d0
         jymodz0tot(j) = 0.d0
         do l = 1,nspec
            jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
            jymodz0tot(j) = jymodz0tot(j) + vec(l)*jymodz0(l,j)
         enddo
         jycorr(j) = jymodtot(j)/jymodz0tot(j)*(1+z)/(1+z0)
      enddo


      if(op.eq.1) then
      
c     Write the results in magnitudes

         do j = 1,nchan
            magmod(j)  = -2.5*log10(jymodtot(j)/jyzero(j))
            magcorr(j) = -2.5*log10(jycorr(j))
         enddo

      else if(op.eq.0) then

         do j = 1,nchan
            magmod(j)  = jymodtot(j)
            magcorr(j) = jycorr(j)
         enddo
      endif



c     Copy the components of vector vec to the output comp
      
      vecfac = DL(z)**2*1d10*3d-9/(1+z)
c      vecfac = 3d-9/(1+z)
      do l = 1,nspec
         comp(l) = vec(l)*vecfac/alpha(l)
c         comp(l) = vec(l)
         err_comp(l) = err_comp(l)*vecfac/alpha(l)
      enddo

      do l1=1,nspec
         do l2=1,nspec
            fmatrix(l1,l2) = fmatrix(l1,l2)*vecfac**2/(alpha(l1)*alpha(l2))
         enddo
      enddo

c      print*,(vec(l),l=1,nspec)
c      print*,(comp(l),l=1,nspec)
c      pause

      xebv1 = ebv1
      xebv2 = ebv2
      xigm  = igm
      chi2  = chimin

      do j=1,nchan
         maguse(j) = jyuse(j)
      enddo

      return
      end

      
      real*8 function err_lum()
      implicit real*8 (a-h,o-z)
      parameter(NSMAX=5,NWMAX=350)

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 lum

      err_lum = 0.d0

      do l1=1,nspec
         err_lum = err_lum + fmatrix(l1,l1)
         do l2=l1+1,nspec
            err_lum = err_lum + 2.d0*fmatrix(l1,l2)
         enddo
      enddo
      err_lum = sqrt(err_lum)

c      do l1=1,nspec
c         write(6,100)(fmatrix(l1,l2),l2=1,nspec)
c 100     format(4ES10.2)
c      enddo
c      pause

      return
      end


      real*8 function err_lum_host()
      implicit real*8 (a-h,o-z)
      parameter(NSMAX=5,NWMAX=350)

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 lum

      err_lum = 0.d0

      do l1=2,nspec
         err_lum = err_lum + fmatrix(l1,l1)
         do l2=l1+1,nspec
            err_lum = err_lum + 2.d0*fmatrix(l1,l2)
         enddo
      enddo
      err_lum_host = sqrt(err_lum)

      return
      end



      subroutine get_chi(jy,ejy,jymod,jyuse,nchan,chi2)
      implicit real*8 (a-h,o-z)
      
      real*8 jy(*),jymod(*),ejy(*)
      integer jyuse(*)


      chi2 = 0.d0

      do j=1,nchan
         if(jyuse(j).ge.1) then
            chi2 = chi2 + ((jy(j)-jymod(j))/ejy(j))**2
         endif
      enddo

      return
      end


      subroutine get_chimag(mag,emag,magmod,maguse,nchan,chi2)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32)

      real*8 mag(*),magmod(*),emag(*)
      integer maguse(*)
      
      real*8 jy(NCMAX),ejy(NCMAX),jymod(NCMAX)

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar


      do jchan=1,nchan
         jy(jchan)   = jyzero(jchan)*10**(-0.4*mag(jchan))
         ejy(jchan)  = jy(jchan)*emag(jchan)*2.5/log(10.)
         jymod(jchan)= jyzero(jchan)*10**(-0.4*magmod(jchan))
      enddo


      chi2 = 0.d0

      do j=1,nchan
         if(maguse(j).eq.1) then
            chi2 = chi2 + ((jy(j)-jymod(j))/ejy(j))**2
         endif
      enddo

      return
      end


      

      subroutine get_mags(comp,z,jymodtot,ebvx1,ebvx2,igmx)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 comp(*),jymodtot(*)
      real*8 vec(NSMAX)

      real*8 ebvx,igmx
      real*8 tigm(NWMAX)

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 jymod(NSMAX,NCMAX)


      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo


      do jchan=1,nchan
        
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z,jchan,kwave)
         enddo
         call getrange(jchan)
         
      enddo


      do k=1,nwave
         tigm(k) = transmit(bcen(k),z,igmx)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymod(l,j) = 0.d0
            do k=jwmin(j),jwmax(j)
               if(l.eq.1) then
                  dust = 10.d0**(-0.4*tau(k)*ebvx1)
               else if(l.eq.5) then
                  dust = 10.d0**(-0.4*tau(k)*ebvx2)
               else
                  dust = 1.d0
               endif
               jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*wgt(j,k)*dust*tigm(k)
            enddo
         enddo
      enddo


      do j=1,nchan
         jymodtot(j)   = 0.d0
         do l = 1,nspec
            jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
         enddo
      enddo


      return
      end




      subroutine get_colors(comp,z,mags,ebvx,igmx)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 comp(*),mags(*)
      real*8 vec(NSMAX)

      real*8 jymodtot(NCMAX)

      real*8 ebvx,igmx
      real*8 tigm(NWMAX)

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 jymod(NSMAX,NCMAX)

      integer jyuse(NCMAX)


c      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      do l = 1,nspec
c         vec(l) = comp(l)*alpha(l)/vecfac
         vec(l) = comp(l)*alpha(l)
      enddo

      do j=1,nchan
         jyuse(j) = 1
      enddo


      do jchan=1,nchan
        
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z,jchan,kwave)
         enddo
         call getrange(jchan)

         if(jwmin(jchan).eq.1) then 
            print*,'jymin(',jchan,') = 1 at z = ',z
         endif

      enddo

      do k=1,nwave
         tigm(k) = transmit(bcen(k),z,igmx)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymod(l,j) = 0.d0
            do k=jwmin(j),jwmax(j)
               if(l.ne.1) then
                  dust = 1.d0
               else
                  dust = 10.d0**(-0.4*tau(k)*ebvx)
               endif
               jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*wgt(j,k)*dust*tigm(k)
            enddo
         enddo
      enddo


      do j=1,nchan
         jymodtot(j)   = 0.d0
         do l = 1,nspec
            jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
         enddo
      enddo
      
      jpiv = nchan
      mags(jpiv) = 20.d0

      do j=1,nchan
         if(j.ne.jpiv) then
            mags(j) = -2.5d0*dlog10(jymodtot(j)/jyzero(j)) + 
     *           2.5d0*dlog10(jymodtot(jpiv)/jyzero(jpiv))
         endif
      enddo


      return
      end


      subroutine get_host_flux(comp,z,jymodtot,ejymodtot,ebvx,igmx)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 comp(*),jymodtot(*),ejymodtot(*)
      real*8 vec(NSMAX)

      real*8 ebvx,igmx
      real*8 tigm(NWMAX)

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 jymod(NSMAX,NCMAX)

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix

      real*8 fmatrix2(NSMAX,NSMAX)



      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
         do k = 1,nspec
            fmatrix2(l,k) = fmatrix(l,k)*alpha(l)*alpha(k)/vecfac**2
         enddo
      enddo


      do jchan=1,nchan
        
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z,jchan,kwave)
         enddo
         call getrange(jchan)
         
      enddo

      do k=1,nwave
         tigm(k) = transmit(bcen(k),z,igmx)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymod(l,j) = 0.d0
            do k=jwmin(j),jwmax(j)
               if(l.ne.1) then
                  dust = 1.d0
               else
                  dust = 10.d0**(-0.4*tau(k)*ebvx)
               endif
               jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*wgt(j,k)*dust*tigm(k)
            enddo
         enddo
      enddo


      do j=1,nchan
         jymodtot(j)   = 0.d0
         do l = 2,nspec
            jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
         enddo
      enddo

      do j=1,nchan
         ejymodtot(j) = 0.d0
         do l=2,nspec
            do k=2,nspec
               ejymodtot(j) = ejymodtot(j) + jymod(l,j)*jymod(k,j)*fmatrix(k,l)
            enddo
         enddo
         ejymodtot(j) = sqrt(ejymodtot(j))
      enddo

      return
      end



      subroutine get_mags_old(comp,z,jymodtot)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 comp(*),jymodtot(*)
      real*8 vec(NSMAX)

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 jymod(NSMAX,NCMAX)



      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo


      do jchan=1,nchan
        
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z,jchan,kwave)
         enddo
         call getrange(jchan)
         
      enddo


      do l=1,nspec
         do j=1,nchan
            jymod(l,j) = 0.0
            do k=jwmin(j),jwmax(j)
               jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*wgt(j,k)
            enddo
            if(jymod(l,j).eq.0.0) then 
c               print*,j,l,jwmin(j),jwmax(j),bedge(jwmin(j)),bedge(jwmax(j))
c               pause
            endif
         enddo
      enddo


      do j=1,nchan
         jymodtot(j)   = 0.0
         do l = 1,nspec
            jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
         enddo
      enddo


      return
      end


      subroutine get_spec_flux(jymod,ebvx,igmx)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 jymod(NSMAX,NCMAX)

      real*8 ebvx,igmx
      real*8 tigm(NWMAX)

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

c      real*8 jymod(NSMAX,NCMAX)


      z = 0.d0

      do jchan=1,nchan
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z,jchan,kwave)
         enddo
         call getrange(jchan)
      enddo

      do k=1,nwave
         tigm(k) = transmit(bcen(k),z,igmx)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymod(l,j) = 0.d0
            do k=jwmin(j),jwmax(j)
               if(l.ne.1) then
                  dust = 1.d0
               else
                  dust = 10.d0**(-0.4*tau(k)*ebvx)
               endif
               jymod(l,j) = jymod(l,j) + spec(l,k)*wgt(j,k)*dust*tigm(k)
            enddo
         enddo
      enddo

      return
      end


      subroutine get_synth_abs_mags(comp,z,abs_mag,ebvx,igmx)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 comp(*),abs_mag(*)
      real*8 jymodtot(NCMAX)
      real*8 vec(NSMAX)

      real*8 ebvx,igmx
      real*8 tigm(NWMAX)

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 jymod(NSMAX,NCMAX)



c      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      vecfac = 1d10*3d-9
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo


      do jchan=1,nchan
        
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(0.d0,jchan,kwave)
         enddo
         call getrange(jchan)
         
      enddo

      do k=1,nwave
         tigm(k) = transmit(bcen(k),z,igmx)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymod(l,j) = 0.d0
            do k=jwmin(j),jwmax(j)
               if(l.ne.1) then
                  dust = 1.d0
               else
                  dust = 10.d0**(-0.4*tau(k)*ebvx)
               endif
               jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*wgt(j,k)*dust*tigm(k)
            enddo
         enddo
      enddo


      do j=1,nchan
         jymodtot(j)   = 0.d0
         do l = 1,nspec
            jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
         enddo
      enddo

c      DM = 5.*log10(DL(z)) + 25.
c      do j=1,nchan
c         abs_mag(j) = -2.5*log10(jymodtot(j)/(1.d0+z)/jyzero(j)) - DM
c      enddo
      do j=1,nchan
         abs_mag(j) = -2.5d0*dlog10(jymodtot(j)/jyzero(j)) - 25.d0
      enddo

      return
      end



      subroutine get_corr(comp,z,z0,jycorr,ebvx,igmx)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 comp(*),jycorr(*)
      real*8 vec(NSMAX)
      real*8 jymodtot(NCMAX),jymodtotz0(NCMAX)

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 ebvx,igmx
      real*8 tigm(NWMAX)

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 jymod(NSMAX,NCMAX),jymodz0(NSMAX,NCMAX)



      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo


      do jchan=1,nchan
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z,jchan,kwave)
         enddo
         call getrange(jchan)
      enddo
      do k=1,nwave
         tigm(k) = transmit(bcen(k),z,igmx)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymod(l,j) = 0.0
            do k=jwmin(j),jwmax(j)
               if(l.ne.1) then
                  dust = 1.d0
               else
                  dust = 10.d0**(-0.4*tau(k)*ebvx)
               endif
               jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*wgt(j,k)*dust*tigm(k)
            enddo
         enddo
      enddo


c     Recalculate the models for z0
      do jchan=1,nchan
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z0,jchan,kwave)
         enddo
         call getrange(jchan)
      enddo
      do k=1,nwave
         tigm(k) = transmit(bcen(k),z,igmx)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymodz0(l,j) = 0.0
            do k=jwmin(j),jwmax(j)
               if(l.ne.1) then
                  dust = 1.d0
               else
                  dust = 10.d0**(-0.4*tau(k)*ebvx)
               endif
               jymodz0(l,j) = jymodz0(l,j) + c(j)*spec(l,k)*wgt(j,k)*dust*tigm(k)
            enddo
         enddo
      enddo


      do j=1,nchan
         jymodtot(j)   = 0.d0
         jymodtotz0(j) = 0.d0
         do l = 1,nspec
            jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
            jymodtotz0(j) = jymodtotz0(j) + vec(l)*jymodz0(l,j)
         enddo
         jycorr(j) = jymodtot(j)/jymodtotz0(j)*(1+z)/(1+z0)
      enddo


      return
      end


      subroutine get_corr_old(comp,z,z0,jycorr)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 comp(*),jycorr(*)
      real*8 vec(NSMAX)
      real*8 jymodtot(NCMAX),jymodtotz0(NCMAX)

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 jymod(NSMAX,NCMAX),jymodz0(NSMAX,NCMAX)



      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo


      do jchan=1,nchan
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z,jchan,kwave)
         enddo
         call getrange(jchan)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymod(l,j) = 0.0
            do k=jwmin(j),jwmax(j)
               jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*wgt(j,k)
            enddo
         enddo
      enddo


c     Recalculate the models for z0
      do jchan=1,nchan
         do kwave=1,nwave
            wgt(jchan,kwave) = getweight(z0,jchan,kwave)
         enddo
         call getrange(jchan)
      enddo
      do l=1,nspec
         do j=1,nchan
            jymodz0(l,j) = 0.0
            do k=jwmin(j),jwmax(j)
               jymodz0(l,j) = jymodz0(l,j) + c(j)*spec(l,k)*wgt(j,k)
            enddo
         enddo
      enddo


      do j=1,nchan
         jymodtot(j)   = 0.d0
         jymodtotz0(j) = 0.d0
         do l = 1,nspec
            jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
            jymodtotz0(j) = jymodtotz0(j) + vec(l)*jymodz0(l,j)
         enddo
         jycorr(j) = jymodtot(j)/jymodtotz0(j)*(1+z)/(1+z0)
      enddo


      return
      end




      subroutine findzlimold(comp,jchan,mlim,zlim,idbg)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 mlim,magl
      real*8 vec(NSMAX),comp(*)

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jymodlim(NSMAX),jymodlimtot


      zlimlow = 0.0d0
      zlimhig = 3.0d0

      icont = 0

 300  continue
      zlim    = 0.5*(zlimhig+zlimlow)


      vecfac = DL(zlim)**2*1e10*3e-9/(1+zlim)
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo


      do kwave=1,nwave
         wgt(jchan,kwave) = getweight(zlim,jchan,kwave)
      enddo
      call getrange(jchan)
         

      do l=1,nspec
         jymodlim(l) = 0.0
         do k=jwmin(jchan),jwmax(jchan)
            jymodlim(l) = jymodlim(l) + 
     *           c(jchan)*spec(l,k)*wgt(jchan,k)
         enddo
      enddo
      jymodlimtot = 0.0
      do l = 1,nspec
         jymodlimtot = jymodlimtot + 
     *        vec(l)*jymodlim(l)
      enddo
      
      magl = -2.5*log10(jymodlimtot/jyzero(jchan))
      if(idbg.eq.1) then
         print*,zlim,zlimhig,zlimlow,magl,mlim
         pause
      endif
      if(magl.le.mlim) zlimlow = zlim
      if(magl.gt.mlim) zlimhig = zlim

      if(abs(magl-mlim).lt.0.002) goto 301
c      if(abs(zlimhig-zlimlow).lt.0.00001d0) then
      if(abs(zlimhig-zlimlow).lt.0.00001d0.and.zlimhig.eq.3.0d0) then
         zlim = 4.
         goto 301
      endif

      icont = icont + 1
      if(icont.gt.100) then
         print*,zlim,zlimhig,zlimlow,magl,mlim
         pause
         goto 301
      endif

      goto 300


 301  continue


      return
      end



      subroutine findzlim(comp,jchan,mlim,zlim,euse,guse,idbg)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 mlim,magl
      real*8 vec(NSMAX),comp(*)

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 jymodlim(NSMAX),jymodlimtot

      real*8 tigm(NWMAX)

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      zlimlow = 0.0d0
      zlimhig = 7.0d0

      icont = 0


 300  continue
      zlim    = 0.5*(zlimhig+zlimlow)


      vecfac = DL(zlim)**2*1e10*3e-9/(1+zlim)
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo


      do kwave=1,nwave
         wgt(jchan,kwave) = getweight(zlim,jchan,kwave)
      enddo
      call getrange(jchan)


      do k = 1,nwave
         tigm(k) = transmit(bcen(k),zlim,guse)
      enddo             

      do l=1,nspec
         jymodlim(l) = 0.0
         do k=jwmin(jchan),jwmax(jchan)
            if(l.ne.1) then
               dust = 1.d0
            else
               dust = 10.d0**(-0.4*tau(k)*euse)
            endif
            jymodlim(l) = jymodlim(l) + 
     *           c(jchan)*spec(l,k)*wgt(jchan,k)*dust*tigm(k)
         enddo
      enddo
      jymodlimtot = 0.0
      do l = 1,nspec
         jymodlimtot = jymodlimtot + 
     *        vec(l)*jymodlim(l)
      enddo
      
      magl = -2.5*log10(jymodlimtot/jyzero(jchan))
      if(idbg.eq.1) then
         print*,zlim,zlimhig,zlimlow,magl,mlim
         pause
      endif
      if(magl.le.mlim) zlimlow = zlim
      if(magl.gt.mlim) zlimhig = zlim

      if(abs(magl-mlim).lt.0.002) goto 301
c      if(abs(zlimhig-zlimlow).lt.0.00001d0) then
      if(abs(zlimhig-zlimlow).lt.0.00001d0.and.zlimhig.eq.4.0d0) then
         zlim = -1.
         goto 301
      endif

      icont = icont + 1
      if(icont.gt.100) then
c         print*,zlim,zlimhig,zlimlow,magl,mlim
c         pause
         goto 301
      endif

      goto 300


 301  continue


      return
      end


      subroutine findLlim(z,jchan,mlim,comp,Llim)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 mlim,comp(*),Llim

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 vec(NSMAX),ncomp(NSMAX)

      real*8 jymod(NSMAX),jymodtot

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar



      tcomp = 0
      do l = 1,nspec
         tcomp = tcomp + comp(l)
      enddo
      do l = 1,nspec
         ncomp(l) = comp(l)/tcomp
      enddo


      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      do l = 1,nspec
         vec(l) = ncomp(l)*alpha(l)/vecfac
      enddo


      do kwave=1,nwave
         wgt(jchan,kwave) = getweight(z,jchan,kwave)
      enddo
      call getrange(jchan)      


      do l=1,nspec
         jymod(l) = 0.0
         do k=jwmin(jchan),jwmax(jchan)
            jymod(l) = jymod(l) + c(jchan)*spec(l,k)*wgt(jchan,k)
         enddo
      enddo
      jymodtot = 0.0
      do l = 1,nspec
         jymodtot  = jymodtot + vec(l)*jymod(l)
      enddo

      Llim = jyzero(jchan)*10**(-0.4*mlim)/jymodtot

      return
      end





      real*8 function apmag(comp,z,jchan)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5,NTMAX=5)

      real*8 vec(NSMAX),comp(*)
      common /dbblock/vec

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 jymodlim(NSMAX,NCMAX),jymodlimtot(NCMAX)
      real*8 jymodlim2(NSMAX,NCMAX)

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave


c      print*,'Hola'

      vecfac = DL(z)**2*1e10*3e-9/(1+z)
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo


      do kwave=1,nwave
         wgt(jchan,kwave) = getweight(z,jchan,kwave)
      enddo
      call getrange(jchan)
         

      do l=1,nspec
         jymodlim(l,jchan) = 0.0
         do k=jwmin(jchan),jwmax(jchan)
c         do k=1,nwave
            jymodlim(l,jchan) = jymodlim(l,jchan) + 
     *           c(jchan)*spec(l,k)*wgt(jchan,k)
         enddo
      enddo



      jymodlimtot(jchan) = 0.0
      do l = 1,nspec
         jymodlimtot(jchan)   = jymodlimtot(jchan) + vec(l)*jymodlim(l,jchan)
      enddo
      
      apmag = -2.5*log10(jymodlimtot(jchan)/jyzero(jchan))     

      
c      print*,apmag, jymodlim(1,jchan),jymodlim(2,jchan),jymodlim(3,jchan)
c      pause


      return 
      end


c     Area is in square degrees
      real*8 function vc(z,area)
      implicit real*8 (a-h,o-z)

c     Comoving Volume for omega_k = 0, according to Hogg 1999.
      domega = (4*3.14159d0/41253.d0)*area 
      vc = (domega/3.d0)*DL(z)**3/(1+z)**3

      return
      end




c     This routine gives back the absolute magnitude of a galaxy
c     just by adding the Distance Modulus. It can be used without
c     K-corrected magnitudes, but it might be meaningless. 
c     The arguments are the following 
c
c
c     nchan  = Number of bands (integer)
c
c     mag    = NCMAX dimensional vector with the magnitudes (real*8)
c
c     z      = redshift of the galaxy (real*8)
c
c     magabs = NCMAX dimensional vector on which absolute magnitudes 
c              are returned (real*8)
c
c     
c     This routine should only be called after calling setdist.


      subroutine abs_mag(mag,nchan,z,magabs)
      implicit real*8 (a-h,o-z)

      real*8 mag(*),magabs(*),z
      integer nchan

      real*8 DM


      DM = 5.d0*dlog10(DL(z)) + 25.d0

      do j = 1,nchan
         magabs(j) = mag(j) - DM
      enddo

      return
      end



c      subroutine close_use_mag(jchan,nchan,jclose)
      subroutine closemag(jchan,nchan,jclose)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32)

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      integer jyuse(NCMAX)
      common /data2/jyuse

      real*8 dist,dist_min

      dist_min = 1.e10

      do j=1,nchan
         if(jyuse(j).ge.1) then
            dist = abs(lbar(jchan)-lbar(j))
            if(dist.lt.dist_min) then
               dist_min = dist
               jclose = j
            endif
         endif
      enddo
      
      return
      end    




      subroutine total_corr(z,jchan,nchan,jcorr,magtotuse)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32)

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      integer jyuse(NCMAX)
      common /data2/jyuse

      integer magtotuse(NCMAX)



      dist_min = 1e20

      do j=1,nchan
c         print*,jyuse(j)
         if(jyuse(j).ge.1.and.magtotuse(j).eq.1) then
            dist = abs(lbar(jchan)-lbar(j)/(1+z))
c            print*,dist,j
            if(dist.lt.dist_min) then
               dist_min = dist
               jcorr = j
            endif
         endif
      enddo

      return
      end




c     Routine to obtain the Bolometric Luminosity of a galaxy.
c     Arguments are:
c
c
c     vec   =  Vector with the same dimensions as number 
c              of templates used for calculating the K 
c              corrections (real*8)
c
c     z     =  Redshift of the galaxy (real*8)
c
c     Lbol  =  Variable used to return the bolometric 
c              luminosity (real*8)
c
c
c     Notice that value of vec is the vector outputed by kca, 
c     so it is necessary to run kca before bol_lum. Also setdist
c     needs to have been called before.
c     Note that if the data used to calculate the k corrections is
c     in Jy, then Lbol will be in units of 10**10 L_sun in erg/s.


      subroutine bol_lum(vec,z,Lbol)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 Lbol
      real*8 vec(*)

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

     
c     The extra factor of speed of light comes from the fact that on 
c     fitgal we are fitting f_lambda to f_nu.

      Lbol = 0.0d0
      do l = 1,nspec
c         Lbol = Lbol + vec(l)/alpha(l)
         Lbol = Lbol + vec(l)
      enddo
c      Lbol = Lbol*DL(z)**2*1e10*3e-9/(1+z)
      

      return 
      end






      subroutine setdist
      implicit real*8 (a-h,o-z)
        
      real*8 zin(1000)      
      real*8 dcom(1000)
      common /distance/dcom,zin,dz,zinmin,zinmax,nin
      
      real*8 om,ol,ok,H0,DH
      common /cosmo/om,ol,ok,H0,DH


      
c     Set the Cosmology here.
      om =  0.3d0
      ol =  0.7d0
      ok =  0.0d0
      H0 = 73.0d0!70.0d0!72.0d0
      

      DH = 3d5/H0

      zinmin = 0.0d0
      zinmax = 7.0d0
      nin  = 701

      dz = (zinmax-zinmin)/float(nin-1)

      do i = 1,nin
         zin(i) = zinmin + dz*float(i-1)
      enddo



      npt     = 100
      dcom(1) = 0.0d0
      do i=1,nin-1
         zmin = zin(i)
         zmax = zin(i+1)
         delz = (zmax-zmin)/float(npt-1) 
         dadd = 0.0d0
         do k=1,npt
            ztemp = zmin + delz*float(k-1)
            x   = ztemp
            val = 1.0/sqrt(om*(1+x)**3+ok*(1+x)**2+ol)
            if (k.ne.1) dadd = dadd + 0.5d0*delz*(val+vold) 
            vold  = val
         enddo
         dcom(i+1) = dcom(i) + DH*dadd
      enddo
      
      return
      end
      


      real*8 function DL(z)
      implicit real*8 (a-h,o-z)
        
      real*8 zin(1000)      
      real*8 dcom(1000)
      common /distance/dcom,zin,dz,zinmin,zinmax,nin
      
      real*8 om,ol,ok,H0,DH
      common /cosmo/om,ol,ok,H0,DH

      real*8 DC,DM

      
      i = (z-zinmin)/dz+1
      if(i.gt.nin) i=nin

      if(zin(i).gt.(z+dz/10.d0)) then
         print*,'problems',z,zin(i),i
         stop
      endif


      npt = 1000
      zmin = zin(i)
      zmax = z
      delz = (zmax-zmin)/float(npt-1) 
      dadd = 0.0d0
      do k=1,npt
         ztemp = zmin + delz*float(k-1)
         x   = ztemp
         val = 1.0/sqrt(om*(1+x)**3+ok*(1+x)**2+ol)
         if (k.ne.1) dadd = dadd + 0.5d0*delz*(val+vold) 
         vold  = val
      enddo
      DC = dcom(i) + DH*dadd
            

      if(ok.gt.0.0d0) then
         DM = DH*sinh(sqrt(ok)*DC/DH)/sqrt(ok)
      else if(ok.lt.0d0) then
         DM = DH*sin(sqrt(-ok)*DC/DH)/sqrt(-ok)
      else
         DM = DC
      endif

      DL = (1+z)*DM

      return
      end







      subroutine gen_kcorr_table
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5)

      real*8 zbin(1000)
      
      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 vec(NSMAX)
      real*8 jymod(NSMAX,NCMAX)
      real*8 jymodtot(NCMAX)
      common /models/jymod,jymodtot,vec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 wgt0(NCMAX,NWMAX)

      real*8 jymodz0(NSMAX,NCMAX),jymodz0tot(NCMAX),jycorr(NSMAX,NCMAX)

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec
      common /specnorm/bminnorm,bmaxnorm

      real*8 zuse

      real*8 alpha(NSMAX)
      common /alphanorm/alpha



c     Build the weights
      
c      print*,'constructing weights '

      zmin = 0.0
      zmax = 1.0
      nz   = 11
      dz   = (zmax-zmin)/float(nz-1)


      open(unit=25,file='kcorrtab.dat',status='unknown')
      write(25,*)nz-1,nchan,nspec

      zuse = 0.

      do iz=1,nz
         zbin(iz) = zmin + dz*float(iz-1)

         do jchan=1,nchan
            wtot = 0.
            do kwave=1,nwave
               wgt(jchan,kwave)  = getweight(zbin(iz),jchan,kwave)
               wgt0(jchan,kwave) = getweight(zuse,jchan,kwave)
               wtot = wtot + wgt0(jchan,kwave) 
            enddo
            if(wtot.eq.0) then
               print*,'wtot = 0',jchan
               pause
            endif
            call getrange(jchan)         
         enddo
      

c     Calculate the models at redshift z and redshift 0 
         
         do l=1,nspec
            do j=1,nchan
               jymod(l,j)   = 0.0
               jymodz0(l,j) = 0.0
c               do k=jwmin(j),jwmax(j)
               do k = 1,160
                  jymod(l,j)   = jymod(l,j) + (1+zbin(iz))*c(j)*spec(l,k)*wgt(j,k)
                  jymodz0(l,j) = jymodz0(l,j) + (1+zuse)*c(j)*spec(l,k)*wgt0(j,k)
               enddo
               jymod(l,j)   = (1e9/3.)*alpha(l)*jymod(l,j)!/(1e10*DL(zbin(iz))**2)
               jymodz0(l,j) = (1e9/3.)*alpha(l)*jymodz0(l,j)!/(1e10*DL(zbin(iz))**2)
            enddo
         enddo
         

c     Write the K Corrections

         do l=1,nspec
            write(25,'(f6.3,1x,i2,40(1x,f13.3))')zbin(iz),l,
     *           (-2.5*log10(jymod(l,j)/jyzero(j)),j=1,nchan),
     *           5*log10(DL(zbin(iz))*1e5)
         enddo

      enddo

      close(25)

      
      return
      end





c This function sets the bands by reading the bands names and the
c zeropoints of the filters.
c The arguments are as follow:
c
c filtname = string containing the name of the file on which the bands
c            and zero points are listed (character*100)
c
c Note that in the filters file, the bands have to be listed in the same
c order as the magnitudes
c are supplied. This is the first function to be called.


      subroutine setfilt(filtname)
      implicit real*8(a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5,NTMAX=5)

      character filtname*(*)

      character*50 bname(NCMAX)
      common /bands/bname

      integer inorm2(NCMAX)
      common /normal/inorm2

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      character*100 line

      real*8 magzero(NCMAX)

      real*8 z
      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan
      common /data1/z

      integer sfrir_ini
      common /ini_sfrir/sfrir_ini
   
      print*,'Reading Filters and Setting Normalizations'
      
      jchan = 0
      open(unit=14,file=filtname,status='old')
 100  read(14,'(a)',end=101)line
      
      if(line(1:1).eq.'#'.or.line(1:1).eq.' ') goto 100
      jchan = jchan + 1
      read(line,*)bname(jchan),inorm2(jchan),jyzero(jchan)
c      jyzero(jchan) = 10**(-0.4*magzero(jchan))
      goto 100

 101  continue

      close(14)
      nchan = jchan
      call setconstants(nchan)
      
c      do jchan = 1,nchan
c         c(jchan)  = 1
c      enddo

c      open(unit=14,file='channel_3s.new',status='old')
c      read(14,*) (c(j),j=1,nchan)
c      close(14)

c     Set the SFR_IR function to be initialized if used
      sfrir_ini = 0

      return
      end





c This function calculates all the necessary constants for the filters calibrations.
c
      
      subroutine setconstants(nchan)
      implicit real*8 (a-h,o-z)
      
      parameter (NCMAX=32,NGMAX=17000,NWMAX=350,NSMAX=5,NTMAX=5)
      
      character*50 bname(NCMAX)
      common /bands/bname
      
      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar
      
      integer nfilt(NCMAX)
      real*8 lamf(NCMAX,11000),eff(NCMAX,11000)
      common /filt1/lamf,eff,nfilt
      
      integer nvega
      real*8 lvega(11000),vegaraw(11000),vinterp(11000)
      common /vega/lvega,vegaraw,vinterp,nvega
     
      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave
      
      character*200 fname
      
      integer VEGA,IRAC,AB
      
      character*20 tname
      
      integer inorm2(NCMAX)
      common /normal/inorm2

      
      VEGA = 1
      IRAC = 2
      AB   = 3
      
      print*,'setting up ',nchan,' bands '

     
c     Read in the Vega spectrum (flambda)
c     also convert angstroms to microns

      open(unit=13,file='/Users/rjassef/.lrt/specs/Vega.sed',form='formatted',status='old')
      read(13,*)nvega
      do i=1,nvega
         read(13,*)lvega(i),vegaraw(i)
         lvega(i)   = lvega(i)/10000.0
         vegaraw(i) = vegaraw(i)*lvega(i)*lvega(i) !Transforming f_lambda to f_nu
      enddo
      close(unit=13)


c     Read the Filters

      do jchan=1,nchan

         write(fname,'(a,a,a)')'/Users/rjassef/.lrt/Filters/',trim(bname(jchan)),'.filter'
         inorm = inorm2(jchan)
         
         open(unit=13,file=fname,status='old')
         read(13,*)nfilt(jchan)
         do i=1,nfilt(jchan)
            read(13,*)lamf(jchan,i),eff(jchan,i)
            lamf(jchan,i) = lamf(jchan,i)/10000.0
            if ((lamf(jchan,i).gt.100).or.(lamf(jchan,i).lt.0.01)) then
               print*,'you probably have an angstron/micron conversion problem '
               print*,'in setconstants for filter ',fname
               stop
            endif
         enddo
         close(unit=13)
            

c     Interpolate the vega spectra onto this grid 

         if (inorm.eq.VEGA) then
            do kwave=1,nfilt(jchan)
               do ll=2,nvega
                  if ((lvega(ll-1).le.lamf(jchan,kwave)).and.(lvega(ll).gt.lamf(jchan,kwave))) then
                     slope          = (lamf(jchan,kwave)-lvega(ll-1))/(lvega(ll)-lvega(ll-1))
                     vinterp(kwave) = vegaraw(ll-1) + slope*(vegaraw(ll)-vegaraw(ll-1))
                  endif
               enddo
            enddo
         endif


c     Construct the normalization constants
c     For IRAC spectrum is  1/nu = lamf
c     For optical spectrum is Vega

         a1 = 0.0
         a2 = 0.0
         a3 = 0.0
         do kwave=2,nfilt(jchan)
            iok = 0
            if (inorm.eq.IRAC) then
               slow = lamf(jchan,kwave-1)
               shig = lamf(jchan,kwave)
               iok  = 1
            endif
            if (inorm.eq.VEGA) then
               slow = vinterp(kwave-1)
               shig = vinterp(kwave)
               iok  = 1
            endif
            if (inorm.eq.AB) then
               slow = 1.0
               shig = 1.0
               iok  = 1
            endif
            if (iok.eq.0) then
               print*,'unknown normalizing spectrum ',inorm,' for band ',bname(jchan)
               stop
            endif

            del  = lamf(jchan,kwave)-lamf(jchan,kwave-1)

            vlow = eff(jchan,kwave-1)/lamf(jchan,kwave-1)**2
            vhig = eff(jchan,kwave  )/lamf(jchan,kwave)**2
            a1 = a1 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan,kwave-1)*slow/lamf(jchan,kwave-1)**2
            vhig = eff(jchan,kwave  )*shig/lamf(jchan,kwave  )**2
            a2 = a2 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan,kwave-1)*slow/lamf(jchan,kwave-1)
            vhig = eff(jchan,kwave  )*shig/lamf(jchan,kwave  )
            a3 = a3 + 0.5*del*(vlow+vhig)

c            if(jchan.gt.nchan) print*,a1,a2,a3,lamf(jchan,kwave),lamf(jchan,kwave-1)

         enddo
         con(jchan) = a2/a1/a3   
         lbar(jchan) = a3/a2    
         print*,'corfac ',jchan,con(jchan),lbar(jchan)
      enddo
      
      print*,'done setting up bands '
      
      return 
      end




c This routine sets the templates needed for the k corrections. 
c Arguments are as follows:
c
c num = number of templates to define the model. Can only be 3 or 4. (integer)
c
c Note that this is the second function to be called, right after setfilt.
c
c'
      subroutine settemp(num)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5,NTMAX=5)
      
      integer num

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      character*100 specname
      character*100 channame

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      integer ivaryobj(NSMAX)
      common /ivary/ivaryobj

      integer ml_ini
      common /ini_ml/ml_ini
      integer ledd_ini
      common /ini_ledd/ledd_ini
      integer sfrir_ini
      common /ini_sfrir/sfrir_ini
      integer agnbol_ini
      common /ini_agnbol/agnbol_ini
      integer agnbolsdss_ini
      common /ini_agnbolsdss/agnbolsdss_ini
      integer lnu5100_ini
      common /ini_lnu5100/lnu5100_ini

      integer nchan_all
      common /all_nchan/nchan_all


c     Read the files with the spectra and with the channel corrections.

      if(num.eq.3) then
         specname = 'agn_spec.dat'
         channame = 'channel.new'
      else if(num.eq.4) then
         specname = 'agn_spec.dat'
         channame = 'channel.new'
      else if(num.eq.5) then
         specname = 'agn_spec.dat'
         channame = 'channel.new'
      else
         print*,'No model with ',num,' templates.'
         print*,'Only 3 and 4 aloud. Exiting program.'
         stop
      endif


      open(unit=14,file=channame,status='old')
      do j=1,nchan
         if(j.le.14) then
            read(14,*) c(j)
         else
            c(j) = 1.d0
         endif
      enddo
      close(14)

c      do j = 1,nchan
c         c(j) = 1
c      enddo


c     Set the range of wavelengths
c     uniformly spaced in log space

      nwave     =  300
      bminl     =  log10(0.03)
      bmaxl     =  log10(30.0)
      
      dbl       = (bmaxl-bminl)/float(nwave)
      do kwave=1,nwave+1
         bedge(kwave)  =  10.0**(bminl+dbl*float(kwave-1))
      enddo
      do kwave=1,nwave
         bcen(kwave) = 0.5*(bedge(kwave)+bedge(kwave+1))
      enddo




c     Read the templates and check the wavelenghts matches with the previous ranges.
      print*,'Reading Templates '
      
      open(unit=13,file=specname,form='formatted',status='old')
      read(13,*)nwt,nspec
      if (nwt.ne.nwave) then
         print*,'startup file has too few wavelengths ',nwt,nwave
         stop
      endif
      do kwave=1,nwave
         read(13,*)bt,tt,(spec(ll,kwave),ll=1,nspec)
         if (abs(bt-bcen(kwave))/bt.gt.0.01) then
            print*,'wavelength mismatch in startup file ',bt,bcen(kwave)
            stop
         endif
      enddo
      close(unit=13)  

c     Now, add the second AGN template in the 5th position.
      nspec = nspec + 1
      do kwave=1,nwave
         spec(nspec,kwave) = spec(1,kwave)
      enddo

c     Initialize the flags to fit the SEDS.
      do l=1,nspec
         ivaryobj(l) = 1
      enddo

c     If 3, block the AGN templates
      if(num.eq.3) then 
         ivaryobj(1) = 0
         ivaryobj(5) = 0
c     If 4, block the second AGN template
      else if(num.eq.4) then
         ivaryobj(5) = 0
      endif

      print*,'Normalizing Templates to 10**10 L_sun'
      do l = 1,nspec
         alpha(l) = 0.d0
c     Setting alpha at 10pc

         do kwave=1,nwave-1
            alpha(l) = alpha(l) + 0.5*(spec(l,kwave+1)/bedge(kwave+1)**2 + 
     *         spec(l,kwave)/bedge(kwave)**2)*(bedge(kwave+1)-bedge(kwave))
         enddo

c         alpha(l) = 3.826e-5/(4*3.14159*3.086**2*alpha(l)) !Sun
         alpha(l) = 3.826e5/(4*3.14159*3.086**2*alpha(l))  !10**10 L_sun

      enddo

      do l = 1,nspec
         print*,'alpha(',l,') = ',alpha(l)
      enddo

c     Set the initialization flags for extra functions.
      ml_ini         = 0
      ledd_ini       = 0
      sfrir_ini      = 0
      agnbol_ini     = 0
      agnbolsdss_ini = 0
      lnu5100_ini    = 0

      nchan_all = nchan

      return
      end






c     Determine the fit coefficients for individual galaxies at fixed template

      subroutine fitgal
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5,NTMAX=5)
      
      real*8 jy(NCMAX),ejy(NCMAX)
      common /data1b/jy,ejy,nchan

      real*8 z
      common /data1/z
      integer jyuse(NCMAX)
      common /data2/jyuse
      
      real*8 vec(NSMAX)
      real*8 jymod(NSMAX,NCMAX)
      real*8 jymodtot(NCMAX)
      common /models/jymod,jymodtot,vec

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar
      
      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec
      common /specnorm/bminnorm,bmaxnorm
      
      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax
      
      integer ivaryobj(NSMAX)
      common /ivary/ivaryobj
      
      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm
      
      real*8 a(10,10),b(10)
      real*8 atemp(10,10),btemp(10)
      real*8 asave(10,10),bsave(10)
      real*8 tempw(10),tempv(10,10),tempz(10)
      integer itempv(10)
      real*8 temps(10),temps2(10)

      real*8 chitabebv1(100),chitabebv2(100),chitabigm(100)
      real*8 tabebv1(100),tabebv2(100),tabigm(100)

      integer ivarysave(NSMAX)
      real*8 tigm(NWMAX)

      logical idored
      common /dored/idored

      real*8 chimin
      common /minchi/chimin

      real*8 vecbest(NSMAX),bestvec(NSMAX),ebvbest,igmbest
      real*8 jymodbest(NSMAX,NCMAX),jymodtotbest(NCMAX)

      real*8 err_comp(NSMAX)
      common /comperr/err_comp

      real*8 jymodx(NSMAX,NCMAX)
      common /modelsx/jymodx

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix

      chimin = 1.d32

      do l = 1,nspec
         ivarysave(l) = ivaryobj(l)
      enddo

      zigmmin = 0.8d0
      
      if(idored) then
         emin1 = -2.0d0 !0.0d0
         emax1 =  1.5d0 !30.d0 !2.5d0
         ne1   = 36 !31 !26
         emin2 = -2.0d0 !0.0d0
         emax2 = -1.0d0 !1.5d0 !30.d0 !2.5d0
         ne2   = 11 !36 !31 !26
         gmin  = 1.d0
         gmax  = 1.d0
         ng    = 1
         if(z.ge.zigmmin) then
            gmin = 0.d0
            gmax = 1.4d0
            ng   = 7
         endif
      else
         emin1 = 0.d0
         emax1 = 0.d0
         ne1   = 1
         emin2 = 0.d0
         emax2 = 0.d0
         ne2   = 1
         gmin  = 1.d0
         gmax  = 1.d0
         ng    = 1
      endif

      ne10 = ne1
      ne20 = ne2
      ng0 = ng
      if(idored) then
         dg   = (gmax-gmin)/float(max(ng-1,1))
         de1  = (emax1-emin1)/float(max(ne1-1,1))         
         de2  = (emax2-emin2)/float(max(ne2-1,1))         
      else
         dg  = 0.d0
         de1 = 0.d0
         de2 = 0.d0
      endif
      do j=1,ne1 
         chitabebv1(j) = 1.d32
      enddo
      do j=1,ne2
         chitabebv2(j) = 1.d32
      enddo
      do j=1,ng
         chitabigm(j) = 1.d32
      enddo     

      do l=1,nspec
         ivaryobj(l) = ivarysave(l)
      enddo


c     Iterate in reddening to find the best fit.
      if(idored) then
         ne1 = ne1+1
         nemax1 = ne1+1
      else
         nemax1 = ne1
         nemax2 = ne2
      endif      


      do ie1=1,nemax1
         ng = 1
         ne2use = 1
         if(ie1.le.ne1) then
            ng = ng0
            ne2use = ne20+1
         endif
         do ie2=1,ne2use
            do ig = 1,ng
               
c     If we are still in the reddening/igm grid step, initialize all
c     parameters to their correct grid value.
               if(ie1.le.ne1) then
                  if(ie1.eq.1) then
                     euse1 = 0.d0               
                  else 
                     euse1 = emin1 + de1*float(ie1-2)
                     euse1 = 10.d0**euse1
                  endif
                  if(ie2.eq.1) then
                     euse2 = 0.d0               
                  else 
                     euse2 = emin2 + de2*float(ie2-2)
                     euse2 = 10.d0**euse2
                  endif
                  guse = gmin + dg*float(ig-1)
c     If not, do quadratic interpolation to get the best-fit values of
c     ebv and igm.
               else
                  euse1 = tabebv1(iebst1)
                  if((iebst1.ne.1).and.(iebst1.ne.ne1)) then
                     y1 = chitabebv1(iebst1-1)
                     y2 = chitabebv1(iebst1  )
                     y3 = chitabebv1(iebst1+1)
                     x1 = tabebv1(iebst1-1)
                     x2 = tabebv1(iebst1  )
                     x3 = tabebv1(iebst1+1)
                     aa = ((y3-y2)*(x2-x1) - (y2-y1)*(x3-x2))/
     *                    ((x3**2-x2**2)*(x2-x1)-(x2**2-x1**2)*(x3-x2))
                     bb = ((y3-y2)-aa*(x3**2-x2**2))/(x3-x2)
                     euse1 = -bb/(2.d0*aa)
                     if((euse1.lt.tabebv1(iebst1-1)).or.
     *                    (euse1.gt.tabebv1(iebst1+1))) 
     *                    euse1 = tabebv1(iebst1)
                  endif
                  euse2 = tabebv2(iebst2)
                  if((iebst2.ne.1).and.(iebst2.ne.ne2)) then
                     y1 = chitabebv2(iebst2-1)
                     y2 = chitabebv2(iebst2  )
                     y3 = chitabebv2(iebst2+1)
                     x1 = tabebv2(iebst2-1)
                     x2 = tabebv2(iebst1  )
                     x3 = tabebv2(iebst2+1)
                     aa = ((y3-y2)*(x2-x1) - (y2-y1)*(x3-x2))/
     *                    ((x3**2-x2**2)*(x2-x1)-(x2**2-x1**2)*(x3-x2))
                     bb = ((y3-y2)-aa*(x3**2-x2**2))/(x3-x2)
                     euse2 = -bb/(2.d0*aa)
                     if((euse2.lt.tabebv2(iebst2-1)).or.
     *                    (euse2.gt.tabebv2(iebst2+1))) 
     *                    euse2 = tabebv2(iebst2)
                  endif
                  guse = tabigm(igbst)
                  if ((igbst.ne.1).and.(igbst.ne.ng)) then
                     den = 2.d0*chitabigm(igbst)-chitabigm(igbst-1)-chitabigm(igbst+1)
                     if (den.lt.0.d0) then
                        guse = tabigm(igbst) +
     *                       0.5*dg*(chitabigm(igbst+1)-chitabigm(igbst-1))/den
                        if((guse.lt.tabigm(igbst-1)).or.(guse.gt.tabigm(igbst+1))) 
     *                       guse = tabigm(igbst)
                     endif
                  endif
               endif

c     Now, move on with calculating the best-fit template contributions
c     and the chi-squared.
               tabebv1(ie1) = euse1
               tabebv2(ie2) = euse2
               tabigm(ig)   = guse
c               chi        = (euse/0.5d0)**2 + ((guse-1.d0)/0.5d0)**2
               chi = 0.d0
      
c     Work out the contribution from each template to the object
               do k = 1,nwave
                  tigm(k) = transmit(bcen(k),z,guse)
               enddo
               do l=1,nspec
                  do j=1,nchan
                     jymod(l,j) = 0.d0
                     do k=jwmin(j),jwmax(j)
                        if(l.eq.1) then
                           dust = 10.d0**(-0.4*tau(k)*euse1)
                        else if(l.eq.5) then
                           dust = 10.d0**(-0.4*tau(k)*euse2)
                        else
                           dust = 1.d0
                        endif
                        jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*
     *                       wgt(j,k)*dust*tigm(k)
                     enddo
                  enddo
               enddo

c     Compute the present model
               maxdim = 10
               call clearmat(atemp,btemp,maxdim,nspec)
               do j=1,nchan
                  if (jyuse(j).ge.1) then
                     do l1=1,nspec
                        btemp(l1) = btemp(l1) + jy(j)*jymod(l1,j)/ejy(j) 
                        do l2=l1,nspec 
                           atemp(l1,l2) = atemp(l1,l2) + jymod(l1,j)*jymod(l2,j)/ejy(j) 
                        enddo
                     enddo
                  endif
               enddo
               call symmat(atemp,btemp,maxdim,nspec)



c     Having built the matrix assuming everything is varying, rearrange
c     the equations for when some are held fixed
c
c     When the reddening is the same for both AGN components, we will
c     hold the 5th one fixed.
               if(ie1.eq.ie2) then
                  ivaryobj(5) = 0
               endif
               nm1 = 0
               do l1=1,nspec
                  if (ivaryobj(l1).eq.1) then
                     nm1    = nm1 + 1 
                     nm2    = 0
                     b(nm1) = btemp(l1)
                     do l2=1,nspec
                        if (ivaryobj(l2).eq.1) then
                           nm2        = nm2 + 1
                           a(nm1,nm2) = atemp(l1,l2)
                        else
                           b(nm1) = b(nm1) - vec(l2)*atemp(l1,l2)
                        endif
                     enddo
                  endif
               enddo

c     Save the matrices
               do l1=1,nm1
                  bsave(l1) = b(l1)
                  do l2=1,nm1
                     asave(l1,l2) = a(l1,l2)
                  enddo
               enddo

 
c     Solve assuming only positive coefficeints
               call my_nnls_2(a,maxdim,nm1,nm1,b,temps,MODE,its,1)

c     If convergence fails, call Andy's version, which is much slower
c     but does not have any convergence issues.
               if(MODE.eq.3) then
                  do l1=1,nm1
                     b(l1) = bsave(l1)
                     do l2=1,nm2
                        a(l1,l2) = asave(l1,l2)
                     enddo
                  enddo
                  nm3 = 0
                  do l=1,nspec
                     if(ivaryobj(l).eq.1) then
                        nm3 = nm3 + 1
                        do j=1,nchan
                           jymodx(nm3,j) = jymod(l,j)
                        enddo
                     endif
                  enddo
                  call ANNLS(a,maxdim,nm1,nm1,b,temps)
               endif
            

c     Copy solution out into final vector
               nm1  = 0
               do l1=1,nspec
                  if (ivaryobj(l1).eq.1) then
                     nm1         = nm1 + 1
                     vec(l1) = temps(nm1)
                  endif
               enddo

               do j=1,nchan
                  jymodtot(j) = 0.d0
                  do l=1,nspec
                     jymodtot(j) = jymodtot(j) + vec(l)*jymod(l,j)
                  enddo
                  if(jyuse(j).ge.1) then
                     diff = jy(j)-jymodtot(j)
                     chi  = chi + diff*diff/ejy(j)
                  endif
               enddo

c     Save the best fit parameters.
               if(chi.le.chitabebv1(ie1)) chitabebv1(ie1) = chi
               if(chi.le.chitabebv2(ie2)) chitabebv2(ie2) = chi
               if(chi.le.chitabigm(ig)) chitabigm(ig) = chi
               if(chi.le.chimin) then
                  chimin = chi
                  ebv1    = euse1
                  ebv2    = euse2
                  igm     = guse
                  iebst1  = ie1
                  iebst2  = ie2
                  igbst   = ig
                  do l=1,nspec
                     vecbest(l) = vec(l)
                     do j=1,nchan
                        jymodbest(l,j) = jymod(l,j)
                     enddo
                  enddo
                  nm1 = 0
                  do l=1,nspec
                     nm1 = nm1 + ivaryobj(l)
                  enddo
                  call gaussj(asave,nm1,maxdim,bsave,1,maxdim)
                  nm1 = 0
                  do l=1,nspec
                     if(ivaryobj(l).eq.1) then
                        nm1 = nm1 + 1
                        err_comp(l) = sqrt(asave(nm1,nm1))
                     else
                        err_comp(l) = 0.d0
                     endif
                  enddo
                  nm1 = 0
                  do l1=1,nspec
                     nm2 = 0                  
                     if(ivaryobj(l1).eq.1) then
                        nm1 = nm1+1
                        do l2=1,nspec
                           if(ivaryobj(l2).eq.1) then
                              nm2 = nm2+1
                              fmatrix(l1,l2) = asave(nm1,nm2)
                           else
                              fmatrix(l1,l2) = 0.d0
                           endif
                        enddo
                     else
                        do l2=1,nspec
                           fmatrix(l1,l2) = 0.d0
                        enddo
                     endif
                  enddo                  
                  do j=1,nchan
                     jymodtotbest(j) = jymodtot(j)
                  enddo
               endif

c     Return the ivaryobj flags to the saved values.
               do l=1,nspec
                  ivaryobj(l) = ivarysave(l)
               enddo

            enddo
         enddo
      enddo

      do l=1,nspec
         ivaryobj(l) = ivarysave(l)
         vec(l) = vecbest(l)
         do j=1,nchan
            jymod(l,j) = jymodbest(l,j)
         enddo
      enddo
      do j=1,nchan
         jymodtot(j) = jymodtotbest(j)
      enddo

      if(ivaryobj(5).eq.0) ebv2 = 0.d0

c      chimin = chimin - ((ebv/0.5d0)**2 + ((igm-1.d0)/0.5d0)**2)

      return
      end






c     This function gets the weights needed to fit the galaxies. I
c     calculates the integral of the filter over two continuous steps in
c     lambda. See the paper for a clearer explanation.


      function getweight(zuse,jchan,kwave)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NWMAX=350,NSMAX=5,NTMAX=5)
      
      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave
      
      real*8 fterp(20),wterp(20)
      
      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar
      
      integer nfilt(NCMAX)
      real*8 lamf(NCMAX,11000),eff(NCMAX,11000)
      common /filt1/lamf,eff,nfilt
      
      wemin = bedge(kwave  )*(1.0+zuse)
      wemax = bedge(kwave+1)*(1.0+zuse)

      
c      if(kwave.eq.nwave) print*,wemin,wemax
      
      nterp = 20
      jj    = 1
      dwe   = (wemax-wemin)/float(nterp-1)
      do kk=1,nterp 
         wterp(kk) = wemin + dwe*float(kk-1)
         fterp(kk) = 0.0
         wedge     = wterp(kk)
         if ((wedge.ge.lamf(jchan,1)).and.(wedge.lt.lamf(jchan,nfilt(jchan)))) then
 100        if (wedge.ge.lamf(jchan,jj+1)) then
               jj = jj + 1
               go to 100
            endif
            if (jj+1.gt.nfilt(jchan)) then
               print*,'bracket went past edge of filter '
               stop
            endif
            if ((wedge.lt.lamf(jchan,jj)).or.(wedge.gt.lamf(jchan,jj+1))) then
               print*,'error in bracket ',lamf(jchan,jj),wedge,lamf(jchan,jj+1)
               print*,jj,nfilt(jchan)
               stop
            endif
            slope     = (wedge-lamf(jchan,jj))/(lamf(jchan,jj+1)-lamf(jchan,jj))
            fterp(kk) = eff(jchan,jj) + slope*(eff(jchan,jj+1)-eff(jchan,jj))
         endif
c         if(jchan.eq.9) print*,fterp(kk),kk,lamf(jchan,nfilt(jchan))
      enddo
c      if(jchan.eq.9) pause

c now do the integral
      getweight = 0.0d0
      do kk=1,nterp-1 
         wlow      = wterp(kk)
         whig      = wterp(kk+1)
         vlow      = fterp(kk  )/wlow
         vhig      = fterp(kk+1)/whig
         getweight = getweight + 0.5*(whig-wlow)*(vhig+vlow)
      enddo
      
c      print*,getweight,con(jchan)
      getweight = con(jchan)*getweight
      
c      if(jchan.eq.9) then
c         print*,con(jchan),getweight
c         pause
c      endif

      return
      end







      subroutine getrange(jchan)
      implicit real*8 (a-h,o-z)
      parameter (NCMAX=32,NGMAX=17000,NWMAX=350,NSMAX=5,NTMAX=5)
      
      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax
      
      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave
      
      real*8 wint(NWMAX)

      integer jyuse(NCMAX)
      common /data2/jyuse


c     Work out the integral

      wint(1) = wgt(jchan,1)
      do kwave=2,nwave
         wint(kwave) = wint(kwave-1) + wgt(jchan,kwave)
      enddo


c     Now work out the contributing range

      wnorm=wint(nwave)


c     Trap worst case error

      if (wnorm.le.0) then
         jwmin(jchan) = 1
         jwmax(jchan) = 1
         jyuse(jchan) = 0
         print*,'no contribution to weights ',jchan,wnorm
         return
      endif
      
c      jwmin(jchan) = 1
c      jwmax(jchan) = nwave
      do kwave=1,nwave
         wint(kwave) = wint(kwave)/wnorm
      enddo
      do kwave=1,nwave
         if (wint(kwave).lt.0.999) jwmax(jchan) = kwave !max(kwave,jwmax(jchan))
      enddo
      do kwave=nwave,1,-1
         if (wint(kwave).gt.0.001) jwmin(jchan) = kwave !min(kwave,jwmin(jchan))
      enddo

c      print*,jwmin(jchan),jwmax(jchan)

      if(jwmin(jchan).gt.1) then
         jwmin(jchan) = jwmin(jchan)-1
      else
c         write(0,*)'Object is at the limit of the spectrum in channel ',jchan
         jyuse(jchan)=0
      endif
      jwmax(jchan) = jwmax(jchan)+1

      return
      end






c     Clear the matrix

      subroutine clearmat(a,b,maxdim,nwave)
      real*8 b(maxdim),a(maxdim,maxdim)

      do k1=1,nwave
         b(k1) = 0.0
         do k2=1,nwave
            a(k1,k2) = 0.0
         enddo
      enddo

      return
      end





c     Symmetrize the matrix

      subroutine symmat(a,b,maxdim,nwave)
      real*8 b(maxdim),a(maxdim,maxdim)
      
      do k1=1,nwave
         do k2=1,k1-1 
            a(k1,k2) = a(k2,k1)
         enddo
      enddo

      return 
      end


      subroutine set_red(ired)
      implicit real*8 (a-h,o-z)
      parameter(NWMAX=350)

      real*8 tau(NWMAX),ebv1,ebv2,igm
      common /dust/tau,ebv1,ebv2,igm

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave
     
      logical idored
      common /dored/idored

      if(ired.eq.1) then
         idored = .true.
      else
         idored = .false.
      endif
         

      if(idored) then
         rv = 3.1
         do kwave=1,nwave
            xarg       = 1.d0/bcen(kwave)
            tau(kwave) = rl(xarg,rv)
         enddo
      endif

      return
      end



c extinction curves -- fixed to SMC dust here
      function rl(x,rv)
      implicit real*8 (a-h,o-z)

      if (x.lt.1.1) then
         a =  0.574*x**1.61
         b = -0.527*x**1.61
      else
         if (x.lt.3.3) then
            y = x-1.82
            a = 1.0+0.17699*y-0.50447*y*y-0.02427*y**3+0.72085*y**4 +
     1           0.01979*y**5-0.77530*y**6+0.32999*y**7
            b = 1.41338*y+2.28305*y**2+1.07233*y**3-5.38434*y**4-
     1           0.62251*y**5+5.30260*y**6-2.09002*y**7
         else
            if (x.lt.8.0) then
               if (x.lt.5.9) then
                  fa = 0.0
                  fb = 0.0
               else
                  fa = -0.04473*(x-5.9)**2 - 0.009779*(x-5.9)**3
                  fb =  0.21300*(x-5.9)**2 + 0.120700*(x-5.9)**3
               endif
               a =  1.752 - 0.316*x - 0.104/((x-4.67)**2+0.341) + fa
               b = -3.090 + 1.825*x + 1.206/((x-4.67)**2+0.263) + fb
            else
               y = x-8.0
               a = -1.073-0.628*y+0.137*y**2-0.070*y**3
               b = 13.670+4.257*y-0.420*y**2+0.374*y**3
            endif
         endif
      endif
      
      rgal = a+b/rv
          
c compute the SMC curve
      c1 = -5.68
      c2 =  2.53
      c3 =  0.76
      x0 =  4.56
      g0 =  1.68
      c4 =  0.60
      
      df = x*x/((x*x-x0*x0)**2+(x*g0)**2)
      if (x.gt.5.9) then
         ff = 0.5392*(x-5.9)**2+0.05644*(x-5.9)**3
      else
         ff = 0.0
      endif
      asmc  = 1.0
      bsmc  = c1 + c2*x + c3*df + c4*ff
      
      rsmc = asmc+bsmc/rv
      
c     if (ismc.eq.1) then
      if (x.lt.4.0) then
         rl = max(rgal,rsmc)
      else
         rl = rsmc
      endif
c     else
c     rl = rgal
c     endif
      
      rl = rv*rl
      

      return
      end


c the transmission bluewards of Lyman alpha
      function transmit(alamrest,zqso,scale)
      implicit real*8 (a-h,o-z)
      

c alamrest = rest wavelength
      alamobs = alamrest*(1.0+zqso)

c wavelength of lyman alpha in microns
      wavelya = 0.121567
      wavelyb = 0.102518
      if (alamrest.ge.wavelya) then
         transmit = 1.0
         return
      endif
      
c     this model is from Fan et al. AJ 132 117 2006
c     Lyman alpha absorbers
      onepzabs = alamobs/wavelya
      tau      = 0.85*(0.2*onepzabs)**4.3
c     Lyman beta absorbers
      if (alamrest.le.wavelyb) then
         onepzabs = alamobs/wavelyb
         tau      = tau + 0.38*(0.2*onepzabs)**4.3
      endif
      
c     Lyman limit absorbers -- uses number of lyman limit
c     systems from Stengler-Larrea et al. ApJ 444 64 1995
c     assumes optical depth of tau0 for an absorber
c     counts up mean number of absorbers to the quasar Lyman limit
c     multiplies by tau0 and uses that as the optical depth to shorter wavelengths
c     wavelength of lyman limit in microns
      wavelylim = 0.091127
      if (alamrest.le.wavelylim) then
         tau0     = 2.0
         onepzabs = 1.0 + zqso
         tau      = tau + 0.1*tau0*(onepzabs**2.5-1.0)
      endif
      
      transmit = exp(-scale*tau)
      
      return
      end

ccc
      SUBROUTINE gaussj(a,n,np,b,m,mp)
      INTEGER m,mp,n,np,NMAX
      REAL*8 a(np,np),b(np,mp)
      PARAMETER (NMAX=50)
      INTEGER i,icol,irow,j,k,l,ll,indxc(NMAX),indxr(NMAX),ipiv(NMAX)
      REAL*8 big,dum,pivinv


      do 11 j=1,n
        ipiv(j)=0
11    continue
      do 22 i=1,n
        big=0.
        do 13 j=1,n
          if(ipiv(j).ne.1)then
            do 12 k=1,n
              if (ipiv(k).eq.0) then
                if (abs(a(j,k)).ge.big)then
                  big=abs(a(j,k))
                  irow=j
                  icol=k
                endif
              else if (ipiv(k).gt.1) then
                pause 'singular matrix in gaussj'
              endif
12          continue
          endif
13      continue
        ipiv(icol)=ipiv(icol)+1
        if (irow.ne.icol) then
          do 14 l=1,n
            dum=a(irow,l)
            a(irow,l)=a(icol,l)
            a(icol,l)=dum
14        continue
          do 15 l=1,m
            dum=b(irow,l)
            b(irow,l)=b(icol,l)
            b(icol,l)=dum
15        continue
        endif
        indxr(i)=irow
        indxc(i)=icol
        if (a(icol,icol).eq.0.) pause 'singular matrix in gaussj'
        pivinv=1./a(icol,icol)
        a(icol,icol)=1.
        do 16 l=1,n
          a(icol,l)=a(icol,l)*pivinv
16      continue
        do 17 l=1,m
          b(icol,l)=b(icol,l)*pivinv
17      continue
        do 21 ll=1,n
          if(ll.ne.icol)then
            dum=a(ll,icol)
            a(ll,icol)=0.
            do 18 l=1,n
              a(ll,l)=a(ll,l)-a(icol,l)*dum
18          continue
            do 19 l=1,m
              b(ll,l)=b(ll,l)-b(icol,l)*dum
19          continue
          endif
21      continue
22    continue
      do 24 l=n,1,-1
        if(indxr(l).ne.indxc(l))then
          do 23 k=1,n
            dum=a(k,indxr(l))
            a(k,indxr(l))=a(k,indxc(l))
            a(k,indxc(l))=dum
23        continue
        endif
24    continue
      return
      END
cccccccccccc
      
      subroutine SFR_IR(comp,ecomp,SFR,dSFR)
      implicit real*8 (a-h,o-z)
      parameter(NWMAX=350,NCMAX=32,NSMAX=5)
      parameter(pi=3.14159d0)

      real*8 comp(*),ecomp(*)
      real*8 vec(NSMAX),evec(NSMAX)

      integer sfrir_ini
      common /ini_sfrir/sfrir_ini

      integer nfilt(NCMAX)
      real*8 lamf(NCMAX,11000),eff(NCMAX,11000)
      common /filt1/lamf,eff,nfilt

      real*8 w_sfrir(NWMAX)

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 jymod_sfrir(NSMAX)
      common /sfrir_jymod/jymod_sfrir

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 Lir,jymodtot

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix

      integer jchan_sfrir
      common /sfrir_extra_channels/jchan_sfrir

      integer error_sfrir
      common /sfrir_error/error_sfrir

      real*8 fmatrix2(NSMAX,NSMAX)

      integer nchan_all
      common /all_nchan/nchan_all


      if(sfrir_ini.eq.1.and.error_sfir.eq.1) then
         SFR = -1.d0
         dSFR= -1.d0
         return
      endif

c     Initialize the function if it has not been initialized before.
      if(sfrir_ini.eq.0) then                 

         print*,'SFR_IR called for the first time'
         print*,'Initializing the function'

         error_sfrir = 0
         sfrir_ini   = 1

         nchan_all = nchan_all + 1
         jchan_sfrir = nchan_all
         if(jchan_sfrir.gt.NCMAX) then
            write(0,*)'Cannot initialize the SFR_IR function'
            write(0,*)'Too many filters used. Decrease the number of bands'
            write(0,*)'or increase NCMAX'
            write(0,*)
            write(0,*)'Returning SFR = -1'
            write(0,*)
            SFR = -1.d0
            dSFR= -1.d0
            error_sfrir = 1
            return
         endif

c     Start by reading the filter curve
         open(unit=95,
     *        file='/Users/rjassef/.lrt/Filters/IRAC_ch4_total_response.filter',
     *        status='old')
         read(95,*)nfilt(jchan_sfrir)
         do i=1,nfilt(jchan_sfrir)
            read(95,*)lamf(jchan_sfrir,i),eff(jchan_sfrir,i)
            lamf(jchan_sfrir,i) = lamf(jchan_sfrir,i)/10000.0
         enddo
         close(95)


c     Set the zero point of the band
         jyzero(jchan_sfrir) = 63.1d0

c     Determine the filter curve calibrations
         a1 = 0.d0
         a2 = 0.d0
         a3 = 0.d0
         do k=2,nfilt(jchan_sfrir)

            slow = lamf(jchan_sfrir,k-1)
            shig = lamf(jchan_sfrir,k)

            del  = lamf(jchan_sfrir,k)-lamf(jchan_sfrir,k-1)

            vlow = eff(jchan_sfrir,k-1)/lamf(jchan_sfrir,k-1)**2
            vhig = eff(jchan_sfrir,k  )/lamf(jchan_sfrir,k)**2
            a1 = a1 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan_sfrir,k-1)*slow/lamf(jchan_sfrir,k-1)**2
            vhig = eff(jchan_sfrir,k  )*shig/lamf(jchan_sfrir,k  )**2
            a2 = a2 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan_sfrir,k-1)*slow/lamf(jchan_sfrir,k-1)
            vhig = eff(jchan_sfrir,k  )*shig/lamf(jchan_sfrir,k  )
            a3 = a3 + 0.5*del*(vlow+vhig)

         enddo
         con(jchan_sfrir) = a2/a1/a3   
         lbar(jchan_sfrir)= a3/a2    

c     Calculate the weights associated to this channel. 
         do k=1,nwave
            wgt(jchan_sfrir,k) = getweight(0.d0,jchan_sfrir,k)
c            print*,wgt(jchan_sfrir,k),jchan_sfrir,k
         enddo
c         pause
         call getrange(jchan_sfrir)         

c     Calculate the band pass flux associated to each template. Only set the
c     galaxy ones, as the AGN contribution should not be counted.
         jymod_sfrir(1) = 0.d0
         do l=2,nspec
            jymod_sfrir(l) = 0.d0
            do k=jwmin(jchan_sfrir),jwmax(jchan_sfrir)
               jymod_sfrir(l) = jymod_sfrir(l) + spec(l,k)*wgt(jchan_sfrir,k)
c               print*,spec(l,k),wgt(jchan_sfrir,k)
            enddo
c            pause
         enddo

      endif


      vecfac = 1d10*3d-9!*DL(z)**2/(1.+z)
      do l1 = 1,nspec
         vec(l1)  = comp(l1) *alpha(l1)/vecfac
         do l2 = 1,nspec
            fmatrix2(l1,l2) = fmatrix(l1,l2)*alpha(l1)*alpha(l2)/vecfac**2
         enddo
      enddo


      jymodtot  = 0.d0
      do l=1,nspec
         jymodtot  = jymodtot  + vec(l) *jymod_sfrir(l)
      enddo
      jymodtot  = jymodtot       *4.d0*pi*1.d-23*(3.086d24)**2/3.839d33


      ejymodtot = 0.d0
      do l1=1,nspec
         ejymodtot = ejymodtot + fmatrix2(l1,l1)*(jymod_sfrir(l1))**2
         do l2=l1+1,nspec
            ejymodtot = ejymodtot + 2.d0*jymod_sfrir(l1)*jymod_sfrir(l2)*
     *           fmatrix2(l1,l2)
         enddo
      enddo
      ejymodtot = sqrt(ejymodtot)*4.d0*pi*1.d-23*(3.086d24)**2/3.839d33
      

c     nu*jymodtot should be a luminosity in units of L_sun if nu is in Hz.

c     Get the IR luminosity using the Bavouzet et al. (2008) relation.
c     Note that the IR luminosity is integrated from 5 to 1000 microns.
      Lir  = 377.9d0*((3d14/lbar(jchan_sfrir))*jymodtot)**0.83d0
      dLIR = (313.66*(3d14/lbar(jchan_sfrir))**0.83 * 
     *     ejymodtot/jymodtot**0.17d0)**2 + (0.37*Lir)**2
      dLIR = sqrt(dLIR)

c     Calibrate it to be 8-1000microns rather than 5-1000microns. 
c     Irrelevant step in every respect.
      Lir  = Lir /1.07d0
      dLir = dLir/1.07d0

c     Get now the SFR using the Kennicutt relation.
      SFR  = Lir /5.8d9
      dSFR = dLir/5.8d9

      return
      end

ccccccccccccccccccccccccc
c
c     Lenticulars are treated as ellipticals!!!!!
c     According to Graham et al. (2007) this is very bad as this 
c     systems usually have B/T of 1/4.
c
      subroutine Ledd_K(comp,ecomp,Ledd,eLedd,Mbh,dMbh,BT)
      implicit real*8 (a-h,o-z)
      parameter(NSMAX=5,NCMAX=32,NWMAX=350)
      

      real*8 comp(*),ecomp(*)
      real*8 vec(NSMAX),evec(NSMAX)

      real*8 Ledd,eLedd

      integer ledd_ini
      common /ini_ledd/ledd_ini

      integer nchan_all
      common /all_nchan/nchan_all

      integer nfilt(NCMAX)
      real*8 lamf(NCMAX,11000),eff(NCMAX,11000)
      common /filt1/lamf,eff,nfilt

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 jymod_ledd(NSMAX)
      common /ledd_jymod/jymod_ledd

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      integer jchan
      common /ledd_extra_channels/jchan

      integer nvega
      real*8 lvega(11000),vegaraw(11000),vinterp(11000)
      common /vega/lvega,vegaraw,vinterp,nvega

      real*8 jymodtot,Mbh,MK

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix

      real*8 fmatrix2(NSMAX,NSMAX)

      real*8 xfac(NSMAX)
c      data xfac/0.0d0, 2.00d-1, 2.00d-1, 2.00d-2/
c      data xfac/0.0d0, 1.0d0, 1.5d-1, 0.0d0/
      data xfac/0.0d0, 1.0d0, 1.0d0, 1.0d0, 0.0d0/


      integer inorm2(NCMAX)
      common /normal/inorm2

      integer VEGA,IRAC,AB

      integer error_ledd
      common /ledd_error/error_ledd


      if(ledd_ini.eq.1.and.error_ledd.eq.1) then
         Ledd  = -1.d0
         dLedd = -1.d0
         Mbh   = -1.d0
         dMbh  = -1.d0
         return
      endif

c     Initialize the function if it has not been initialized before.
      if(ledd_ini.eq.0) then        
        
         print*,'Ledd_K called for the first time'
         print*,'Initializing the function'

c     Set the initialization flag to done.
         ledd_ini = 1
         error_ledd = 0

         nchan_all = nchan_all + 1
         jchan = nchan_all
         if(jchan.gt.NCMAX) then
            write(0,*)'Cannot initialize the Ledd_K function'
            write(0,*)'Too many filters used. Decrease the number of bands'
            write(0,*)'or increase NCMAX'
            write(0,*)
            write(0,*)'Returning Ledd = -1'
            write(0,*)
            error_ledd = 1
            Ledd  = -1.d0
            dLedd = -1.d0
            Mbh   = -1.d0
            dMbh  = -1.d0
            return
         endif

c     Start by reading the filter curve
         open(unit=95,
     *        file='/Users/rjassef/.lrt/Filters/kband.filter',
     *        status='old')
         read(95,*)nfilt(jchan)
         do i=1,nfilt(jchan)
            read(95,*)lamf(jchan,i),eff(jchan,i)
            lamf(jchan,i) = lamf(jchan,i)/10000.0
         enddo
         close(95)

         VEGA = 1
         IRAC = 2
         AB   = 3

c     Set the zero points of the bands
         jyzero(jchan) = 675.7d0 !666.7d0
         inorm2(jchan) = VEGA
c         jyzero(jchan) = 3631.d0
c         inorm2(jchan) = AB

c     Determine the filter curve calibrations
         inorm = inorm2(jchan)
         a1 = 0.d0
         a2 = 0.d0
         a3 = 0.d0
         do k=2,nfilt(jchan)

            iok = 0
            if (inorm.eq.IRAC) then
               slow = lamf(jchan,k-1)
               shig = lamf(jchan,k)
               iok  = 1
            endif
            if (inorm.eq.VEGA) then
               slow = vinterp(k-1)
               shig = vinterp(k)
               iok  = 1
            endif
            if (inorm.eq.AB) then
               slow = 1.d0
               shig = 1.d0
               iok  = 1
            endif
            
            del  = lamf(jchan,k)-lamf(jchan,k-1)

            vlow = eff(jchan,k-1)/lamf(jchan,k-1)**2
            vhig = eff(jchan,k  )/lamf(jchan,k)**2
            a1 = a1 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan,k-1)*slow/lamf(jchan,k-1)**2
            vhig = eff(jchan,k  )*shig/lamf(jchan,k  )**2
            a2 = a2 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan,k-1)*slow/lamf(jchan,k-1)
            vhig = eff(jchan,k  )*shig/lamf(jchan,k  )
            a3 = a3 + 0.5*del*(vlow+vhig)

         enddo
         con(jchan) = a2/a1/a3   
         lbar(jchan)= a3/a2    

c     Calculate the weights associated to this channel. 
         do k=1,nwave
            wgt(jchan,k) = getweight(0.d0,jchan,k)
c            print*,wgt(jchan,k),jchan,k
         enddo
c         pause
         call getrange(jchan)         

c     Calculate the band pass flux associated to each template. Only set the
c     galaxy ones, as the AGN contribution should not be counted.
         jymod_ledd(1) = 0.d0
         do l=2,nspec
            jymod_ledd(l) = 0.d0
            do k=jwmin(jchan),jwmax(jchan)
               jymod_ledd(l) = jymod_ledd(l) + spec(l,k)*wgt(jchan,k)
            enddo
         enddo

      endif

      ehat = 0.d0
      do l=2,nspec
         ehat = ehat + comp(l)
      enddo
      if(ehat.eq.0.d0) then
         Ledd  = -1.d0
         dLedd = -1.d0
         Mbh   = -1.d0
         dMbh  = -1.d0
         return
      endif
      ehat = comp(2)/ehat

c      print*,ehat

      vecfac  = 1d10*3d-9!*DL(z)**2/(1.+z)
      do l = 1,nspec
         vec(l)  = comp(l) *alpha(l)/vecfac
         evec(l) = ecomp(l)*alpha(l)/vecfac
      enddo
      do l1=1,nspec
         do l2=1,nspec
            fmatrix2(l1,l2) = fmatrix(l1,l2) * alpha(l1)*alpha(l2)/vecfac**2
         enddo
      enddo

      jymodtot  = 0.d0
      do l=1,nspec
         jymodtot  = jymodtot  + xfac(l)*vec(l)*jymod_ledd(l)
      enddo     

      ejymodtot = 0.d0
      do l1=1,nspec
         ejymodtot = ejymodtot + (xfac(l1)*jymod_ledd(l1))**2*fmatrix2(l1,l1)
         do l2=l1+1,nspec
            ejymodtot = ejymodtot + 2.d0*xfac(l1)*xfac(l2)*
     *           jymod_ledd(l1)*jymod_ledd(l2)*fmatrix2(l1,l2)
         enddo
      enddo
      ejymodtot = sqrt(ejymodtot)

c     Exit if there is no host. Otherwise, calculate MK
      if(jymodtot.eq.0.d0) then
         Ledd = -1.d0
         eLedd= -1.d0
         Mbh  = -1.d0
         dMbh = -1.d0
         return
      endif
      MK  = -2.5d0*dlog10(jymodtot/jyzero(jchan)) - 25.d0
      dMK = (2.5d0/dlog(10.d0))*ejymodtot/jymodtot      

c     Get the Mbh usign the relation of Graham (2007). The intrinsic scatter is 0.3dex
      a = -0.37d0
c      a = -0.4d0
      b = 8.29d0
c      a = -0.52d0
c      b = 8.11d0
      Mbh  = a*(MK+24) + b
      Mbh  = 10.d0**(Mbh)
      dMbh = (a*dMK)**2 + 0.30**2
      dMbh = dlog(10.d0)*Mbh*sqrt(dMbh)

c     Get the Eddington Luminosity.
      Ledd  = 3.28d4*Mbh
      eLedd = 3.28d4*dMbh

c     Get the B/T ratio used.
      T = 0.d0
      B = 0.d0
      do l=2,nspec
         B = B + xfac(l)*vec(l)*jymod_ledd(l)
         T = T +         vec(l)*jymod_ledd(l)
      enddo
      BT = B/T

      return
      end

cccccccccccccccccccccccccc
c
c     Mass to Light ratios estimated from g-r color and K band Luminosity
c     calibrations c of Bell et al. (2003). A correction of -0.15dex is taken
c     to change the IMF from "diet" Salpeter to Kroupa, as the latter should
c     be a description of galaxies.
c
      subroutine ML_Bell03_II(comp,ecomp,M,dM,totML,etotML)
      implicit real*8 (a-h,o-z)
      parameter(NWMAX=350,NCMAX=32,NSMAX=5)
      parameter(pi=3.14159d0)

      real*8 M,dM,totML,etotML
      real*8 comp(*),ecomp(*)
      real*8 vec(NSMAX),evec(NSMAX)

      integer ml_ini
      common /ini_ml/ml_ini

      integer nfilt(NCMAX)
      real*8 lamf(NCMAX,11000),eff(NCMAX,11000)
      common /filt1/lamf,eff,nfilt

      real*8 w_ml(NWMAX)

      real*8 jy(NCMAX),ejy(NCMAX)
      integer nchan
      common /data1b/jy,ejy,nchan

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 jymod_ml(3,NSMAX)
      common /ml_jymod/jymod_ml

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      real*8 Lir,jymodtot(3),ejymodtot(3)

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix

      integer jchan_ml(3)
      common /ml_extra_channels/jchan_ml

      integer error_ml
      common /ml_error/error_ml

      integer nvega
      real*8 lvega(11000),vegaraw(11000),vinterp(11000)
      common /vega/lvega,vegaraw,vinterp,nvega

      real*8 pdev(3),lmat(3,3)!,ML(NSMAX)
      real*8 fmatrix2(NSMAX,NSMAX)

      real*8 ML(NSMAX)
      common /ml_values/ML

      integer inorm2(NCMAX)
      common /normal/inorm2

      integer VEGA,IRAC,AB

      integer nchan_all
      common /all_nchan/nchan_all

      real*8 Lum

      real*8 tfac(NSMAX)
c      data tfac/0.d0,1.d0,0.2d0,0.0d0/
      data tfac/0.d0,1.d0,1.d0,1.d0,0.d0/


      if(ml_ini.eq.1.and.error_ml.eq.1) then
         M = -1.d0
         dM= -1.d0
         return
      endif

c     Initialize the function if it has not been initialized before.
      if(ml_ini.eq.0) then        
        
         print*,'ML_Bell03 called for the first time'
         print*,'Initializing the function'
         
         error_ml = 0
         ml_ini   = 1

         nchan_all = nchan_all + 3         
         jchan_ml(1) = nchan_all-1
         jchan_ml(2) = nchan_all
         jchan_ml(3) = nchan_all-2
         if(nchan_all.gt.NCMAX) then
            write(0,*)'Cannot initialize the ML_Bell03 function'
            write(0,*)'Too many filters used. Decrease the number of bands'
            write(0,*)'or increase NCMAX'
            write(0,*)
            write(0,*)'Returning ML = -1'
            write(0,*)
            M = -1.d0
            dM= -1.d0
            error_ml=1
            return
         endif

c     Start by reading the filter curves
         do j=1,3
            if(j.eq.1) then
               open(unit=95,
     *         file='/Users/rjassef/.lrt/Filters/sdssg.filter',
     *              status='old')
            else if(j.eq.2) then
               open(unit=95,
     *         file='/Users/rjassef/.lrt/Filters/sdssr.filter',
     *              status='old')
            else
               open(unit=95,
     *         file='/Users/rjassef/.lrt/Filters/kband.filter',
     *              status='old')
c               open(unit=95,
c     *         file='/Users/rjassef/.lrt/Filters/K_atmccd.filter',
c     *              status='old')
            endif
            read(95,*)nfilt(jchan_ml(j))
            do i=1,nfilt(jchan_ml(j))
               read(95,*)lamf(jchan_ml(j),i),eff(jchan_ml(j),i)
               lamf(jchan_ml(j),i) = lamf(jchan_ml(j),i)/10000.d0
            enddo
            close(95)
         enddo

         VEGA = 1
         IRAC = 2
         AB   = 3

c     Set the zero points of the bands
         jyzero(jchan_ml(1)) = 3631.d0
         inorm2(jchan_ml(1)) = AB

         jyzero(jchan_ml(2)) = 3631.d0
         inorm2(jchan_ml(2)) = AB

         jyzero(jchan_ml(3)) = 666.7d0
         inorm2(jchan_ml(3)) = Vega
         
        

c     Determine the filter curve calibrations
         do j=1,3      

c     Interpolate the vega spectra onto this grid 

            inorm = inorm2(jchan_ml(j))

            if (inorm.eq.VEGA) then
               do k=1,nfilt(j)
                  do ll=2,nvega
                     if ((lvega(ll-1).le.lamf(j,k)).and.(lvega(ll).gt.lamf(j,k))) then
                        slope          = (lamf(j,k)-lvega(ll-1))/(lvega(ll)-lvega(ll-1))
                        vinterp(k) = vegaraw(ll-1) + slope*(vegaraw(ll)-vegaraw(ll-1))
                     endif
                  enddo
               enddo
            endif
      
            a1 = 0.d0
            a2 = 0.d0
            a3 = 0.d0

            do k=2,nfilt(jchan_ml(j))               

               iok = 0
               if (inorm.eq.IRAC) then
                  slow = lamf(jchan,k-1)
                  shig = lamf(jchan,k)
                  iok  = 1
               endif
               if (inorm.eq.VEGA) then
                  slow = vinterp(k-1)
                  shig = vinterp(k)
                  iok  = 1
               endif
               if (inorm.eq.AB) then
                  slow = 1.d0
                  shig = 1.d0
                  iok  = 1
               endif
              
               del  = lamf(jchan_ml(j),k)-lamf(jchan_ml(j),k-1)
               
               vlow = eff(jchan_ml(j),k-1)/lamf(jchan_ml(j),k-1)**2
               vhig = eff(jchan_ml(j),k  )/lamf(jchan_ml(j),k)**2
               a1 = a1 + 0.5*del*(vlow+vhig)
        
               vlow = eff(jchan_ml(j),k-1)*slow/lamf(jchan_ml(j),k-1)**2
               vhig = eff(jchan_ml(j),k  )*shig/lamf(jchan_ml(j),k  )**2
               a2 = a2 + 0.5*del*(vlow+vhig)
               
               vlow = eff(jchan_ml(j),k-1)*slow/lamf(jchan_ml(j),k-1)
               vhig = eff(jchan_ml(j),k  )*shig/lamf(jchan_ml(j),k  )
               a3 = a3 + 0.5*del*(vlow+vhig)
c               if(j.eq.3) then
c                  print*,del,slow,shig
c                  pause
c               endif
            enddo
            con(jchan_ml(j)) = a2/a1/a3   
            lbar(jchan_ml(j))= a3/a2    
c            print*,j,a1,a2,a3
         enddo

c     Calculate the weights associated to this channel. 
         do j=1,3
            do k=1,nwave
               wgt(jchan_ml(j),k) = getweight(0.d0,jchan_ml(j),k)
c               print*,wgt(jchan_ml(j),k),k,jchan_ml(j)            
            enddo
            call getrange(jchan_ml(j))    
c            pause
         enddo

c     Calculate the band pass flux associated to each template. Only set the
c     galaxy ones, as the AGN contribution should not be counted.
         do j=1,3
            jymod_ml(j,1) = 0.d0
            do l=2,nspec
               jymod_ml(j,l) = 0.d0
               do k=jwmin(jchan_ml(j)),jwmax(jchan_ml(j))
                  jymod_ml(j,l) = jymod_ml(j,l) + spec(l,k)*wgt(jchan_ml(j),k)
               enddo
            enddo
         enddo

c     Calculate the M/L of each template. 
         j1 = jchan_ml(1)
         j2 = jchan_ml(2)
         j3 = jchan_ml(3)
         a3 = -0.209d0 - 0.15d0
         b3 = 0.197d0
         ML(1) = 0.d0
         do l=2,nspec
            color = -2.5d0*dlog10(jymod_ml(1,l)/jymod_ml(2,l)*
     *           jyzero(j2)/jyzero(j1))
            ML(l) = 10.d0**(a3 + b3*color)
         enddo
         
      endif
      z = 0.d0
c      z = 1.74d0
c      vecfac = DL(z)**2*1d10*3d-9/(1+z)
      vecfac = 1.d10*3d-9
      do l = 1,nspec
         vec(l) = comp(l)*alpha(l)/vecfac
      enddo
      do l1=1,nspec
         do l2=1,nspec
            fmatrix2(l1,l2) = fmatrix(l1,l2)*alpha(l1)*alpha(l2)/(vecfac**2)
         enddo
      enddo

      
c     Get the mass
      j3 = jchan_ml(3)
      M = 0.d0
      do l=1,nspec
         flux = vec(l)*jymod_ml(3,l)/(1.d0+z)
c         print*,flux
c         xmag = -2.5d0*dlog10(flux/jyzero(j3)) - (5.d0*dlog10(DL(z))+25.d0)
         xmag = -2.5d0*dlog10(flux/jyzero(j3)) - 25.d0
         flum = 10.d0**(-0.4d0*(xmag-3.32d0))
         M = M + tfac(l)*flum*ML(l)
c         print*,M,tfac(l),flum,ML(l),nspec
      enddo

      dM = 0.d0
      do l1=1,nspec
c         xfactor1 = ML(l1)*(jymod_ml(3,l1)/jyzero(j3))*(DL(z)*1.d6/10.d0)**2 *
c     *        10.d0**(0.4d0*3.32d0)
         xfactor1 = ML(l1)*(jymod_ml(3,l1)/jyzero(j3))*(1.d6/10.d0)**2 *
     *        10.d0**(0.4d0*3.32d0)
         do l2=1,nspec
c            xfactor2 = ML(l2)*(jymod_ml(3,l2)/jyzero(j3))*(DL(z)*1.d6/10.d0)**2 *
c     *        10.d0**(0.4d0*3.32d0)
            xfactor2 = ML(l2)*(jymod_ml(3,l2)/jyzero(j3))*(1.d6/10.d0)**2 *
     *        10.d0**(0.4d0*3.32d0)
            dM = dM + xfactor1*xfactor2*fmatrix2(l1,l2)
         enddo
      enddo
      dM = dsqrt(dM+(0.1d0*M)**2)

c     Calculate now the error in the overall M/L ratio.
      Lum = 0.d0
      xM  = 0.d0
      do l=2,nspec
         Lum = Lum + alpha(l)*jymod_ml(3,l)*comp(l)
         xM  = xM  + alpha(l)*jymod_ml(3,l)*tfac(l)*ML(l)*comp(l)
      enddo
      if(L.gt.0.d0) then
         totML = xM/Lum
      else
         totML = -1.d0
      endif
      
      etotML = 0.d0
      if(L.gt.0.d0) then
         do l1=2,nspec
            xfactor1 = jymod_ml(3,l1)*alpha(l1)*
     *           (tfac(l1)*ML(l1)/Lum - xM/Lum**2)
            do l2=2,nspec
               xfactor2 = jymod_ml(3,l2)*alpha(l2)*
     *           (tfac(l2)*ML(l2)/Lum - xM/Lum**2)
               etotML = etotML + xfactor1*xfactor2*fmatrix(l1,l2)
            enddo
         enddo
         etotML = sqrt(etotML+(0.1d0)**2*totML**2)
      else
         etotML = -1.d0
      endif

      return
      end

ccccccccccccccccccccccccc
c
c     Subroutine that calculates the AGN bolometric luminosity by
c     following the calibrations of Hopkins et al. (2006) which are partly
c     based on the work of Marconi et al. (2004).  
c
      subroutine AGN_bol_lum(comp,ecomp,Ledd,eLedd,Lagn,eLagn)
      implicit real*8 (a-h,o-z)
      parameter(NSMAX=5,NCMAX=32,NWMAX=350)
      parameter(pi=3.14159d0)

      real*8 comp(*),ecomp(*)
      real*8 vec(NSMAX),evec(NSMAX)

      real*8 Ledd,eLedd
      real*8 Lagn,eLagn

      integer agnbol_ini
      common /ini_agnbol/agnbol_ini

      integer nchan_all
      common /all_nchan/nchan_all

      integer nfilt(NCMAX)
      real*8 lamf(NCMAX,11000),eff(NCMAX,11000)
      common /filt1/lamf,eff,nfilt

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 jymod_agnbol(NSMAX)
      common /agnbol_jymod/jymod_agnbol

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      integer nvega
      real*8 lvega(11000),vegaraw(11000),vinterp(11000)
      common /vega/lvega,vegaraw,vinterp,nvega

      real*8 FB,LB

      integer inorm2(NCMAX)
      common /normal/inorm2

      integer VEGA,IRAC,AB

      integer error_agnbol
      common /agnbol_error/error_agnbol

      integer jchan_agnbol
      common /agnbol_extra_channels/jchan

      real*8 ac,bc,cc
      common /cubic_coeffs/ac,bc,cc

      real*8 x(3),lambda,mdot


      if(agnbol_ini.eq.1.and.error_agnbol.eq.1) then
         Lagn  = -1.d0
         eLagn = -1.d0
         return
      endif

c     Initialize the function if it has not been initialized before.
      if(agnbol_ini.eq.0) then        
        
         print*,'AGN_bol_lum called for the first time'
         print*,'Initializing the function'

c     Set the initialization flag to done.
         agnbol_ini   = 1
         error_agnbol = 0

         nchan_all = nchan_all + 1
         jchan = nchan_all
         if(jchan.gt.NCMAX) then
            write(0,*)'Cannot initialize the AGN_bol_lum function'
            write(0,*)'Too many filters used. Decrease the number of bands'
            write(0,*)'or increase NCMAX'
            write(0,*)
            write(0,*)'Returning Lagn = -1'
            write(0,*)
            error_agnbol = 1
            Lagn  = -1.d0
            eLagn = -1.d0
            return
         endif

c     Start by reading the filter curve
         open(unit=95,
     *        file='/Users/rjassef/.lrt/Filters/B_bessell.filter',
     *        status='old')
         read(95,*)nfilt(jchan)
         do i=1,nfilt(jchan)
            read(95,*)lamf(jchan,i),eff(jchan,i)
            lamf(jchan,i) = lamf(jchan,i)/10000.0
         enddo
         close(95)

         VEGA = 1
         IRAC = 2
         AB   = 3

c     Set the zero points of the bands
         jyzero(jchan) = 4063.d0
         inorm2(jchan) = VEGA

c     Determine the filter curve calibrations
         inorm = inorm2(jchan)
         a1 = 0.d0
         a2 = 0.d0
         a3 = 0.d0
         do k=2,nfilt(jchan)

            iok = 0
            if (inorm.eq.IRAC) then
               slow = lamf(jchan,k-1)
               shig = lamf(jchan,k)
               iok  = 1
            endif
            if (inorm.eq.VEGA) then
               slow = vinterp(k-1)
               shig = vinterp(k)
               iok  = 1
            endif
            if (inorm.eq.AB) then
               slow = 1.d0
               shig = 1.d0
               iok  = 1
            endif
            
            del  = lamf(jchan,k)-lamf(jchan,k-1)

            vlow = eff(jchan,k-1)/lamf(jchan,k-1)**2
            vhig = eff(jchan,k  )/lamf(jchan,k)**2
            a1 = a1 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan,k-1)*slow/lamf(jchan,k-1)**2
            vhig = eff(jchan,k  )*shig/lamf(jchan,k  )**2
            a2 = a2 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan,k-1)*slow/lamf(jchan,k-1)
            vhig = eff(jchan,k  )*shig/lamf(jchan,k  )
            a3 = a3 + 0.5*del*(vlow+vhig)

         enddo
         con(jchan) = a2/a1/a3   
         lbar(jchan)= a3/a2    

c     Calculate the weights associated to this channel. 
         do k=1,nwave
            wgt(jchan,k) = getweight(0.d0,jchan,k)
c            print*,wgt(jchan,k),jchan,k
         enddo
c         pause
         call getrange(jchan)         

c     Calculate the B-band flux associated to the AGN.  Do not consider
c     reddening or IGM absorption c as we are interested in the intrinsic
c     luminosity.
         do l=1,nspec
            jymod_agnbol(l) = 0.d0
         enddo
         do k=jwmin(jchan),jwmax(jchan)
            jymod_agnbol(1) = jymod_agnbol(1) + spec(1,k)*wgt(jchan,k)
         enddo

c     Set the cubic equation coefficients that must be solved if the
c     objection has a high accretion rate.
         ac =  0.017d0/(-0.0023d0)
         bc = -1.067d0/(-0.0023d0)

      endif

c     If the eddington luminosity is zero (i.e. there is no host detected), abort.
c      if(Ledd.le.0.d0) then
c         Lagn  = -1.d0
c         eLagn = -1.d0
c         return
c      endif

c     If there is no AGN component, exit the function.
      if(comp(1).eq.0.d0) then
         Lagn  =  0.d0
         eLagn = -1.d0
         return
      endif

      vecfac  = 1d10*3d-9!*DL(z)**2/(1.+z)
      do l = 1,nspec
         vec(l)  = comp(l) *alpha(l)/vecfac
         evec(l) = ecomp(l)*alpha(l)/vecfac
      enddo

c     Get the B-band luminosity.
      FB = vec(1)*jymod_agnbol(1)*1.d-23
c      FB = FB*3.d14/con(jchan)
      LB = FB*3.d18/4450.d0
      LB = LB*4.d0*pi/3.839d33*(3.086d24)**2

c     Do the first estimation of the AGN luminosity and the accretion rate.
      Lagn = 17.d0*LB
c      write(6,700)Lagn,comp(1)*1e10
      if(Ledd.gt.0.d0) then
         mdot = Lagn/Ledd
      else 
         mdot = 1.d0
      endif

c     Separate the two cases of the Hopkins et al. (2006) criteria.
      if(mdot.gt.1.d-1) then

c         LB = LB*con(jchan)/3.d14

c         xlLagn = dlog10(Lagn)-12
c         cB = 0.8d0-0.067d0*xlLagn+0.017d0*xlLagn**2-0.0023*xlLagn**3
c         cB = 10.d0**cB
c         Lagn = cB*LB           !*3.d18/4450.d0

c         write(6,700)Lagn
c 700     format(4ES20.6)


c         cc = (0.8d0-12.d0+dlog10(LB*3.d18/4450.d0))/-0.0023d0
         cc = (0.8d0-12.d0+dlog10(LB))/(-0.0023d0)

         call cubic(ac,bc,cc,x)
         Lagn = 10.d0**(x(1)+12.d0)

c         write(6,700)Lagn
c         pause

         R = (2.d0*ac**3-9.d0*ac*bc+27.d0*cc)/54.d0
         Q = (a**2-3.d0*b)
         A = -abs(R)/R * (abs(R)+sqrt(R**2-Q**3))**(1.d0/3.d0)

         dc   = ecomp(1)/comp(1)/0.0023d0/dlog(10.d0)

         dR   = 0.5d0*dc

         if(R.gt.0.d0) then 
            dabsRdR = 1.d0
         else
            dabsRdR = -1.d0
         endif
         dAdR = (1.d0/3.d0)*(abs(R)+sqrt(R**2-Q**3))**(-2.d0/3.d0)*
     *        (dabsRdR + R/sqrt(R**2-Q**3))
         dA   = abs(dAdR) * dR

         eLagn = (1.d0-Q/A**2)*dA * Lagn * dlog(10.d0)

      else

         lambda = Lagn/Ledd
         cB     = 11.d0*(lambda/0.01d0)**(-0.25d0)
         Lagn   = cB*LB
         
         eLagn  = (0.75d0*ecomp(1)/comp(1))**2 + (0.25d0*eLedd/Ledd)**2
         eLagn  = Lagn*sqrt(eLagn)

      endif
      
c      print*,cB
c      write(6,700)Lagn,comp(1)*1.d10,comp(1)*1.d10/Lagn,-2.5d0*dlog10(FB*1.d23/jyzero(jchan))-10*2.5d0
c      pause

      return
      end

cccccccccccccccccccccccc

      subroutine cubic(a,b,c,x)
      implicit real*8(a-h,o-z)
      parameter (pi=3.14159d0)

      real*8 x(3)

      Q = (a**2-3.d0*b)/9.d0
      R = (2.d0*a**3-9.d0*a*b+27.d0*c)/54.d0

      if(R**2.lt.Q**3) then
         theta = acos(R/sqrt(Q**3))
         x(1) = -2.d0*sqrt(Q)*cos( theta         /3.d0)-a/3.d0
         x(2) = -2.d0*sqrt(Q)*cos((theta+2.d0*pi)/3.d0)-a/3.d0
         x(3) = -2.d0*sqrt(Q)*cos((tehta-2.d0*pi)/3.d0)-a/3.d0
      else
         Am = (-R/abs(R))*(abs(R)+sqrt(R**2-Q**3))**(1.d0/3.d0)
         if(Am.eq.0.d0) then
           Bm = 0.d0
        else
           Bm = Q/Am
        endif
        x(1) = (Am+Bm) - a/3.d0
c     Do not consider the other two solutions, as they are not real.
        x(2) = 0.d0
        x(3) = 0.d0
      endif

      return
      end


cccccccccccccccccccccccccccccccccccc
c     This correction comes from Gallagher et al. (2006) and is based on the
c     Richards et al. (2006) mean SDSS QSO SED and the 3.6micron luminosity of
c     the objects.
c
      subroutine AGN_bol_lum_SDSS(comp,ecomp,Lagn,eLagn)
      implicit real*8 (a-h,o-z)
      parameter(NSMAX=5,NCMAX=32,NWMAX=350)
      parameter(pi=3.14159d0)

      real*8 comp(*),ecomp(*)
      real*8 vec(NSMAX),evec(NSMAX)

      real*8 Ledd,eLedd
      real*8 Lagn,eLagn

      integer agnbolsdss_ini
      common /ini_agnbolsdss/agnbolsdss_ini

      integer nchan_all
      common /all_nchan/nchan_all

      integer nfilt(NCMAX)
      real*8 lamf(NCMAX,11000),eff(NCMAX,11000)
      common /filt1/lamf,eff,nfilt

      real*8 jyzero(NCMAX),sat(NCMAX),con(NCMAX),lbar(NCMAX)
      common /cal1/jyzero,sat,con,lbar

      real*8 wgt(NCMAX,NWMAX)
      real*8 c(NCMAX)
      common /weights1/wgt,c
      integer jwmin(NCMAX),jwmax(NCMAX)
      common /weights2/jwmin,jwmax 

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 jymod_agnbolsdss(NSMAX)
      common /agnbolsdss_jymod/jymod_agnbolsdss

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      integer nvega
      real*8 lvega(11000),vegaraw(11000),vinterp(11000)
      common /vega/lvega,vegaraw,vinterp,nvega

      real*8 F36,L36

      integer inorm2(NCMAX)
      common /normal/inorm2

      integer VEGA,IRAC,AB

      integer error_agnbolsdss
      common /agnbolsdss_error/error_agnbolsdss

      integer jchan_agnbolsdss
      common /agnbolsdss_extra_channels/jchan

      real*8 ac,bc,cc
      common /cubic_coeffs/ac,bc,cc

      real*8 x(3),lambda,mdot


      if(agnbolsdss_ini.eq.1.and.error_agnbolsdss.eq.1) then
         Lagn  = -1.d0
         eLagn = -1.d0
         return
      endif

c     Initialize the function if it has not been initialized before.
      if(agnbolsdss_ini.eq.0) then        
        
         print*,'AGN_bol_lum_SDSS called for the first time'
         print*,'Initializing the function'

c     Set the initialization flag to done.
         agnbolsdss_ini   = 1
         error_agnbolsdss = 0

         nchan_all = nchan_all + 1
         jchan = nchan_all
         if(jchan.gt.NCMAX) then
            write(0,*)'Cannot initialize the AGN_bol_lum function'
            write(0,*)'Too many filters used. Decrease the number of bands'
            write(0,*)'or increase NCMAX'
            write(0,*)
            write(0,*)'Returning Lagn = -1'
            write(0,*)
            error_agnbolsdss = 1
            Lagn  = -1.d0
            eLagn = -1.d0
            return
         endif

c     Start by reading the filter curve
         open(unit=95,
     *        file='/Users/rjassef/.lrt/Filters/IRAC_ch1_total_response.filter',
     *        status='old')
         read(95,*)nfilt(jchan)
         do i=1,nfilt(jchan)
            read(95,*)lamf(jchan,i),eff(jchan,i)
            lamf(jchan,i) = lamf(jchan,i)/10000.0
         enddo
         close(95)

         VEGA = 1
         IRAC = 2
         AB   = 3

c     Set the zero points of the bands
         jyzero(jchan) = 277.5d0
         inorm2(jchan) = IRAC

c     Determine the filter curve calibrations
         inorm = inorm2(jchan)
         a1 = 0.d0
         a2 = 0.d0
         a3 = 0.d0
         do k=2,nfilt(jchan)

            iok = 0
            if (inorm.eq.IRAC) then
               slow = lamf(jchan,k-1)
               shig = lamf(jchan,k)
               iok  = 1
            endif
            if (inorm.eq.VEGA) then
               slow = vinterp(k-1)
               shig = vinterp(k)
               iok  = 1
            endif
            if (inorm.eq.AB) then
               slow = 1.d0
               shig = 1.d0
               iok  = 1
            endif
            
            del  = lamf(jchan,k)-lamf(jchan,k-1)

            vlow = eff(jchan,k-1)/lamf(jchan,k-1)**2
            vhig = eff(jchan,k  )/lamf(jchan,k)**2
            a1 = a1 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan,k-1)*slow/lamf(jchan,k-1)**2
            vhig = eff(jchan,k  )*shig/lamf(jchan,k  )**2
            a2 = a2 + 0.5*del*(vlow+vhig)

            vlow = eff(jchan,k-1)*slow/lamf(jchan,k-1)
            vhig = eff(jchan,k  )*shig/lamf(jchan,k  )
            a3 = a3 + 0.5*del*(vlow+vhig)

         enddo
         con(jchan) = a2/a1/a3   
         lbar(jchan)= a3/a2    

c     Calculate the weights associated to this channel. 
         do k=1,nwave
            wgt(jchan,k) = getweight(0.d0,jchan,k)
c            print*,wgt(jchan,k),jchan,k
         enddo
c         pause
         call getrange(jchan)         

c     Calculate the [3.6] flux associated to the AGN.  Do not consider
c     reddening or IGM absorption c as we are interested in the intrinsic
c     luminosity.
         do l=1,nspec
            jymod_agnbolsdss(l) = 0.d0
            do k=jwmin(jchan),jwmax(jchan)
               jymod_agnbolsdss(l) = jymod_agnbolsdss(l) + spec(l,k)*wgt(jchan,k)
            enddo
         enddo

      endif

c     If there is no AGN component, exit the function.
      if(comp(1).eq.0.d0) then
         Lagn  =  0.d0
         eLagn = -1.d0
         return
      endif

      vecfac  = 1.d10*3.d-9!*DL(z)**2/(1.d0+z)
      do l = 1,nspec
         vec(l)  = comp(l) *alpha(l)/vecfac
         evec(l) = ecomp(l)*alpha(l)/vecfac
      enddo

c     Get the [3.6] luminosity.
c      F36 = 0.d0
c      do l=1,nspec
c         F36 = F36 + vec(l)*jymod_agnbolsdss(l)*1.d-23
c      enddo      
      F36 = vec(1)*jymod_agnbolsdss(1)*1.d-23
c      L36 = F36*1.85d13
c      L36 = F36*3.d14/3.6d0
      L36 = 4.d0*pi*(3.086d24)**2*F36/3.839d33
c      L36 = L36*4.d0*pi/3.839d33*(3.086d24)**2

c     Estimate the AGN luminosity
c      Lagn = 8.59d0*L36*(3.d0/3.6d0)**1.8d0
      Lagn = 8.59d0*1d14*L36*(3.d0/3.6d0)**2.8d0

c     Estimate the error
      eL36 = L36 * evec(1)/vec(1)
      eLagn = 8.59d0*eL36

      return
      end

cccccccccccccc

      subroutine get_Lnu5100(comp,L5100,eL5100,L5100agn,eL5100agn)
      implicit real*8 (a-h,o-z)
      parameter(NSMAX=5,NCMAX=32,NWMAX=350)
      parameter(pi=3.14159d0)

      real*8 comp(*),L5100,eL5100,L5100agn,eL5100agn

      real*8 vec(NSMAX),f5100(NSMAX)

      real*8 fmatrix(NSMAX,NSMAX)
      common /fisher/fmatrix

      real*8 fmatrix2(NSMAX,NSMAX)

      integer lnu5100_ini
      common /ini_lnu5100/lnu5100_ini

      real*8 bedge(NWMAX)
      real*8 bcen(NWMAX)
      common /wavegrid/bedge,bcen,nwave

      real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
      common /specmod1/spec,specuse,nspec

      real*8 alpha(NSMAX)
      common /alphanorm/alpha

      integer error_lnu5100
      common /lnu5100_error/error_lnu5100

      real*8 lamtarg


      if(lnu5100_ini.eq.1.and.error_lnu5100.eq.1) then
         L5100     = -1.d0
         eL5100    = -1.d0
         L5100agn  = -1.d0
         eL5100agn = -1.d0
         return
      endif

c     Initialize the function if it has not been initialized before.
      if(lnu5100_ini.eq.0) then        
        
         print*,'get_Lnu5100 called for the first time'
         print*,'Initializing the function'

c     Set the initialization flag to done.
         lnu5100_ini   = 1
         error_lnu5100 = 0

c     Find the closest wavelenghts to 5100A
         lamtarg = 0.51d0
         ksave = -1
         do k=1,nwave
            if(bcen(k).gt.lamtarg) then
               ksave = k
               goto 100
            endif
         enddo
         print*,'Could not find lambda > 5100. Exiting function.'
         error_lnu5100 = 1
         L5100  = -1.d0
         eL5100 = -1.d0
         L5100agn  = -1.d0
         eL5100agn = -1.d0
         return
 100     continue

c     Interpolate the templates to get the natural fluxes at wavelength 5100         
         do l=1,nspec
            slope    = (spec(l,ksave)-spec(l,ksave-1))/(bcen(ksave)-bcen(ksave-1))
            f5100(l) = slope * (lamtarg - bcen(ksave)) + spec(l,ksave)
         enddo
            
      endif

c     Get the vectors and the fisher matrix in natural units
      vecfac = 1d10*3d-9!DL(z)**2/(1+z)
      do l1 = 1,nspec
         vec(l1) = comp(l1)*alpha(l1)/vecfac
         do l2=1,nspec
            fmatrix2(l1,l2) = fmatrix(l1,l1)*alpha(l1)*alpha(l2)/vecfac**2
         enddo
      enddo

c     Get the flux and transform it into a luminosity
      fnu = 0.d0
      do l=1,nspec
         fnu = fnu + vec(l)*f5100(l)
      enddo
      fnu   = fnu*1.d-23
      L5100 = fnu*4.d0*pi*(3.086d24)**2

c     Now get the errors in this flux
      efnu = 0.d0
      do l1=1,nspec
         do l2=1,nspec
            efnu = efnu + f5100(l1)*f5100(l2)*fmatrix2(l1,l2)
         enddo
      enddo
      efnu   = sqrt(efnu)*1.d-23
      eL5100 = efnu*4.d0*pi*(3.086d24)**2

c     Now get the pure AGN values
      fnuagn    = vec(1)*f5100(1)*1.d-23
      L5100agn  = fnuagn*4.d0*pi*(3.086d24)**2
      efnuagn   = f5100(1)*sqrt(fmatrix2(1,1))*1.d-23
      eL5100agn = efnuagn*4.d0*pi*(3.086d24)**2      

      return
      end
      

